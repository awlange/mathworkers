<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: mathworkers.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: mathworkers.js</h1>

    


    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 *  MathWorkers.js
 *
 *  A JavaScript math library that uses Web Workers for parallelization
 *
 *  https://github.com/awlange/mathworkers
 *
 *  Copyright 2014 Adrian W. Lange
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 *  @file MathWorkers.js library
 *  @version 1.0.0
 *  @copyright Adrian W. Lange
 *  @author Adrian W. Lange
 */

var MathWorkers = (function() {
"use strict";

/**
 * The MathWorkers module
 * @exports MathWorkers
 */
var MathWorkers = {};

// Copyright 2014 Adrian W. Lange

// TODO: This can probably be combined with the var global
/**
 * Methods that affect global behavior of MathWorkers.
 *
 * @namespace MathWorkers.Global
 */
MathWorkers.Global = {};

/**
 *  Data available globally only within the MathWorkers class
 *  @ignore
 */
var global = {};

// For documentation and such. Make sure to update on releases.
global.version = "1.0.0";
/**
 * Retrieve the MathWorkers code version
 *
 * @returns {string}
 */
MathWorkers.Global.getVersion = function () {
    return global.version;
};

// Globally scoped useful variables, defaults
global.workerPool = [];
global.nWorkers = 1;
global.myWorkerId = 0;

global.logLevel = 1;
/**
 * &lt;p>Sets the MathWorkers log level:&lt;/p>
 * &lt;ul>
 *   &lt;li> 1 = warnings and errors only &lt;/li>
 *   &lt;li> 2 = verbose logging &lt;/li>
 * &lt;/ul>
 * &lt;p>Default is 1.&lt;/p>
 *
 * @param {!number} logLevel level to be set
 * @memberof MathWorkers.Global
 * @function setLogLevel
 */
MathWorkers.Global.setLogLevel = function(logLevel) {
    if (!MathWorkers.util.nullOrUndefined(logLevel)) {
        global.logLevel = logLevel;
    }
};

global.unrollLoops = false;
/**
 * &lt;p>Loop unrolling option:&lt;/p>
 * &lt;ul>
 *   &lt;li>If true, use loop unrolled versions of functions if available.&lt;/li>
 *   &lt;li>If false, do not use loop unrolling.&lt;/li>
 * &lt;/ul>
 * &lt;p>Default is false.&lt;/p>
 *
 * @param {!boolean} unroll option to be set
 * @memberof MathWorkers.Global
 * @function setUnrollLoops
 */
MathWorkers.setUnrollLoops = function(unroll) {
    MathWorkers.util.checkNullOrUndefined(unroll);
    global.unrollLoops = unroll;
};

/**
 * Creates the internal Web Worker pool, if Web Worker supported.
 *
 * @ignore
 */
global.createPool = function(nWorkersInput, workerScriptName) {
    MathWorkers.util.checkWebWorkerSupport();
	for (var i = 0; i &lt; nWorkersInput; ++i) {
		var worker = new Worker(workerScriptName);
		worker.postMessage({handle: "_init", id: i, nWorkers: nWorkersInput,
            logLevel: global.logLevel, unrollLoops: global.unrollLoops});
		this.workerPool.push(worker);
        this.nWorkers = this.workerPool.length;
	}

	this.getWorker = function(workerId) {
		return this.workerPool[workerId];
	};
};

// Copyright 2014 Adrian W. Lange

/**
 * General utility functions intended for internal use
 *
 * @ignore
 */
MathWorkers.util = {};

/**
 * Verify that the environment executing this code has Web Worker support
 *
 * @ignore
 * @throws {Error}
 */
MathWorkers.util.checkWebWorkerSupport = function() {
    if (typeof(Worker) === "undefined") {
        throw Error("Web Worker support not available for MathWorkers.");
    }
};

/**
 * Load balancing function.
 * Divides n up evenly among the number of workers in the pool.
 * Any remainder is distributed such that no worker has more than 1 extra piece in its range.
 *
 * @ignore
 * @returns {object} container for range index from (inclusive) and index to (non-inclusive)
 */
MathWorkers.util.loadBalance = function(n) {
    var id = global.myWorkerId;
	var div = (n / global.nWorkers)|0;
	var rem = n % global.nWorkers;

	var ifrom;
	var ito;
	if (id &lt; rem) {
		ifrom = id * (div + 1);
		ito = ifrom + div + 1;
	} else {
		ifrom = id * div + rem;
		ito = ifrom + div;
	}

	return {ifrom: ifrom, ito: ito};
};

/**
 * Test if the variable x is null or undefined
 *
 * @ignore
 * @param x variable to be tested
 * @return {boolean} true if x is null or undefined
 */
MathWorkers.util.nullOrUndefined = function(x) {
    return x === undefined || x === null;
};

/**
 * Verify that x is neither null nor undefined.
 *
 * @ignore
 * @throws {TypeError}
 */
MathWorkers.util.checkNullOrUndefined = function(x) {
    if (MathWorkers.util.nullOrUndefined(x)) {
        throw new TypeError("Undefined or null variable.");
    }
};

/**
 * Verify that x is a Number and not null or undefined
 *
 * @ignore
 * @throws {TypeError}
 */
MathWorkers.util.checkNumber = function(x) {
    MathWorkers.util.checkNullOrUndefined(x);
    if (typeof x != 'number') {
        throw new TypeError("Expected type Number but is type " + typeof x);
    }
};

/**
 * Verify that x is a Function and not null or undefined
 *
 * @ignore
 * @throws {TypeError}
 */
MathWorkers.util.checkFunction = function(x) {
    MathWorkers.util.checkNullOrUndefined(x);
    if (typeof x != 'function') {
        throw new TypeError("Expected type Function but is type " + typeof x);
    }
};

/**
 * Verify that x is an Array or Float64Array and not null or undefined
 *
 * @ignore
 * @throws {TypeError}
 */
MathWorkers.util.checkArray = function(x) {
    MathWorkers.util.checkNullOrUndefined(x);
    if (!(x instanceof Array || x instanceof Float64Array)) {
        throw new TypeError("Expected type Array but is type " + typeof x);
    }
};

/**
 * Verify that x is a Float64Array and not null or undefined
 *
 * @ignore
 * @throws {TypeError}
 */
MathWorkers.util.checkFloat64Array = function(x) {
    MathWorkers.util.checkNullOrUndefined(x);
    if (!(x instanceof Float64Array)) {
        throw new TypeError("Expected type Float64Array but is type " + typeof x);
    }
};

/**
 * Verify that v is a Vector and is not null or undefined
 *
 * @ignore
 * @throws {TypeError}
 */
MathWorkers.util.checkVector = function(v) {
    MathWorkers.util.checkNullOrUndefined(v);
    if (!(v instanceof MathWorkers.Vector)) {
        throw new TypeError("Expected type Vector but is not.");
    }
};

/**
 * Verify that Vectors v and w are equal length and not null or undefined
 *
 * @ignore
 * @throws {TypeError}
 * @throws {Error}
 */
MathWorkers.util.checkVectors = function(v, w) {
    MathWorkers.util.checkVector(v);
    MathWorkers.util.checkVector(w);
    if (v.length !== w.length) {
        throw new Error("Vectors have unequal lengths.");
    }
};

/**
 * Verify that Vector v and Matrix A are compatible for vector-matrix products
 * and are both not null or undefined
 *
 * @ignore
 * @throws {TypeError}
 * @throws {Error}
 */
MathWorkers.util.checkVectorMatrix = function(v, A) {
    MathWorkers.util.checkVector(v);
    MathWorkers.util.checkMatrix(A);
    if (v.length !== A.nrows) {
        throw new Error("Vector length and number Matrix rows are unequal.");
    }
};

/**
 * Verify that A is a Matrix and is not null or undefined
 *
 * @ignore
 * @throws {TypeError}
 */
MathWorkers.util.checkMatrix = function(A) {
    MathWorkers.util.checkNullOrUndefined(A);
    if (!(A instanceof MathWorkers.Matrix)) {
        throw new TypeError("Expected type Matrix but is not.");
    }
};

/**
 * Verify that Matrix A and Matrix B have equal dimensions and are neither null nor undefined
 *
 * @ignore
 * @throws {TypeError}
 * @throws {Error}
 */
MathWorkers.util.checkMatrices = function(A, B) {
    MathWorkers.util.checkMatrix(A);
    MathWorkers.util.checkMatrix(B);
    if (!(A.nrows === B.nrows &amp;&amp; A.ncols === B.ncols)) {
        throw new Error("Matrices do not have equal numbers of rows and columns.");
    }
};

/**
 * Verify that Matrix A and Vector v are compatible for matrix-vector products
 * and are both not null or undefined
 *
 * @ignore
 * @throws {TypeError}
 * @throws {Error}
 */
MathWorkers.util.checkMatrixVector = function(A, v) {
    MathWorkers.util.checkMatrix(A);
    MathWorkers.util.checkVector(v);
    if (v.length !== A.ncols) {
        throw new Error("Vector length and number Matrix columns are unequal.");
    }
};

/**
 * Verify that Matrix A and Matrix B have compatible dimensions for matrix-matrix
 * multiplication and are neither null nor undefined
 *
 * @ignore
 * @throws {TypeError}
 * @throws {Error}
 */
MathWorkers.util.checkMatrixMatrix = function(A, B) {
    MathWorkers.util.checkMatrix(A);
    MathWorkers.util.checkMatrix(B);
    if (A.ncols !== B.nrows) {
        throw new Error("Matrices do not have compatible dimensions for matrix-matrix multiplication.");
    }
};

// Copyright 2014 Adrian W. Lange

/**
 * Custom event emitter. To be inherited by classes involving events.
 * Based on example provided here:
 *
 * http://otaqui.com/blog/1374/event-emitter-pub-sub-or-deferred-promises-which-should-you-choose/
 *
 * @mixin
 */
function EventEmitter() {
    var events = {};

    /**
     * Sets an event to listen for
     *
     * @param {!string} name the event name
     * @param {function} callback the callback to be executed when the event is emitted
     */
    this.on = function(name, callback) {
        MathWorkers.util.checkFunction(callback);
        events[name] = [callback];
    };

    /**
     * Emits an event and executes the corresponding callback
     *
     * @param {!string} name the event name
     * @param {Array.&lt;Object>} [args] an array of arguments to be passed to the callback
     */
    this.emit = function(name, args) {
        events[name] = events[name] || [];
        args = args || [];
        events[name].forEach( function(fn) {
            fn.call(this, args);
        });
    };
}

// Copyright 2014 Adrian W. Lange

/**
 * Coordinator for browser-side interface.
 * Coordinates the pool of Workers for computations and message passing.
 *
 * @param {!number} nWorkersInput the number of Workers to spawn in the pool
 * @param {!string} workerScriptName the name of the script that the Workers are to execute
 * @constructor
 * @mixes EventEmitter
 * @memberof MathWorkers
 */
MathWorkers.Coordinator = function(nWorkersInput, workerScriptName) {
	var that = this;

	/**
	 * Buffer for data received from worker pool
	 *
	 * @member {Object}
	 * @private
	 */
	var objectBuffer = {};

	/**
	 * Message buffer for messages received from worker pool. Order of
	 * messages in array corresponds to the MathWorker id.
	 *
	 * @member {Array}
	 * @private
	 */
	var messageDataBuffer = [];

	/**
	 * True when all spawned workers have reported that they are ready. False otherwise.
	 *
	 * @member {boolean}
	 */
	this.ready = false;

	// Create the worker pool, which starts the workers
	global.createPool(nWorkersInput, workerScriptName);

	/**
	 * Once all workers in the pool report that they are ready, execute the callback.
	 *
	 * @param {function} callBack callback function to be executed
	 */
	this.onReady = function(callBack) {
		that.on("_ready", callBack);
	};

    /**
     * Fetches the object buffer contents.
     * After a message from one or more workers is received, the object
     * buffer is typically populated with data.
     *
     * @returns {Object}
     */
	this.getBuffer = function() {
		return objectBuffer;
	};

    /**
     * Fetches the message data list contents.
     * After a message from one or more workers is received, the object
     * buffer is usually populated with data.
     *
     * @returns {Array}
     */
	this.getMessageDataList = function() {
		return messageDataBuffer;
	};

    /**
     * Cause an event registered by the MathWorker pool to execute.
     *
     * @param {!string} tag the unique label for the event being triggered
     * @param {Array} [args] an array of arguments to be passed to the callback to be executed
     */
	this.trigger = function(tag, args) {
		for (var wk = 0; wk &lt; global.nWorkers; ++wk) {
			global.getWorker(wk).postMessage({handle: "_trigger", tag: tag, args: args});
		}
	};

	/**
	 * Broadcasts data to all workers
	 *
	 * @param {Object} data JSON-serializable data to be sent
	 * @param {!string} tag message tag
	 */
	this.sendDataToWorkers = function(data, tag) {
		for (var wk = 0; wk &lt; global.nWorkers; ++wk) {
			global.getWorker(wk).postMessage({handle: "_broadcastData", tag: tag, data: data});
		}
	};

	/**
	 * Broadcast a Vector to all workers
	 *
	 * @param {!MathWorkers.Vector} vec Vector to be sent
	 * @param {!string} tag message tag
	 */
	this.sendVectorToWorkers = function(vec, tag) {
		// Must make a copy of the vector for each worker for transferable object message passing
		for (var wk = 0; wk &lt; global.nWorkers; ++wk) {
			var v = new Float64Array(vec.array);
			global.getWorker(wk).postMessage({handle: "_broadcastVector", tag: tag,
				vec: v.buffer}, [v.buffer]);
		}
	};

	/**
	 * Broadcast a Matrix to all workers
	 *
	 * @param {!MathWorkers.Matrix} mat Matrix to be sent
	 * @param {!string} tag message tag
	 */
	this.sendMatrixToWorkers = function(mat, tag) {
		// Must make a copy of each matrix row for each worker for transferable object message passing
		for (var wk = 0; wk &lt; global.nWorkers; ++wk) {
			var matObject = {handle: "_broadcastMatrix", tag: tag, nrows: mat.nrows};
			var matBufferList = [];
			for (var i = 0; i &lt; mat.nrows; ++i) {
				var row = new Float64Array(mat.array[i]);
				matObject[i] = row.buffer;
				matBufferList.push(row.buffer);
			}
			global.getWorker(wk).postMessage(matObject, matBufferList);
		}
	};

    /**
	 * The onmessage router for all workers.
     * Routes the event appropriately based on the message handle.
     *
     * @param event {Object} web worker event from message passing
     * @private
     */
 	var onmessageHandler = function(event) {
 		var data = event.data;
 		switch (data.handle) {
 			case "_workerReady":
 				handleWorkerReady();
 				break;
 			case "_sendData":
 				handleSendData(data);
 				break;
 			case "_vectorSendToCoordinator":
 				handleVectorSendToCoordinator(data);
 				break;
 			case "_gatherVector":
 				handleGatherVector(data);
 				break;
 			case "_matrixSendToCoordinator":
 				handleMatrixSendToCoordinator(data);
 				break;
 			 case "_gatherMatrixRows":
 				handleGatherMatrixRows(data);
 				break;
            case "_gatherMatrixColumns":
                handleGatherMatrixColumns(data);
                break;
  			case "_vectorSum":
 				handleVectorSum(data);
 				break;
            case "_vectorProduct":
                handleVectorProduct(data);
                break;
 			default:
 				console.error("Invalid Coordinator handle: " + data.handle);
 		}
 	};

 	// Register the above onmessageHandler for each worker in the pool
 	// Also, initialize the message data buffer with empty objects
 	for (var wk = 0; wk &lt; global.nWorkers; ++wk) {
 		global.getWorker(wk).onmessage = onmessageHandler;
 		messageDataBuffer.push({});
 	}

 	// Reduction function variables
 	var nWorkersReported = 0;

	/**
	 * Accumulate the number of reported workers. Once all workers have reported,
	 * emit the special "_ready" event to cause onReady() to execute.
	 *
	 * @private
	 */
 	var handleWorkerReady = function() {
 		nWorkersReported += 1;
 		if (nWorkersReported == global.nWorkers) {
 			that.ready = true;
 			that.emit("_ready");
 			// reset for next message
			nWorkersReported = 0;	
 		}
 	};

	/**
	 * Accumulate messages from workers into the messageDataBuffer array.
	 * Emits the message tag event.
	 *
	 * @param data {!Object} message data
	 * @private
	 */
 	var handleSendData = function(data) {
 		messageDataBuffer[data.id] = data.data;
 		nWorkersReported += 1;
 		if (nWorkersReported == global.nWorkers) {
 			that.emit(data.tag);
 			// reset for next message
			nWorkersReported = 0;	
 		}
 	};

	/**
	 * Copies Vector sent from a worker into a Vector stored
	 * temporarily in the Coordinator objectBuffer.
	 * Emits the message tag event.
	 *
	 * @param data {!Object} message data
	 * @private
	 */
	var handleVectorSendToCoordinator = function(data) {
		objectBuffer = new MathWorkers.Vector();
		objectBuffer.setVector(new Float64Array(data.vectorBuffer));
		that.emit(data.tag);
	};

	/**
	 * Copies Matrix sent from a worker into a Matrix stored
	 * temporarily in the Coordinator objectBuffer.
	 * Emits the message tag event.
	 *
	 * @param data {!Object} message data
	 * @private
	 */
	var handleMatrixSendToCoordinator = function(data) {
        var tmp = [];
		for (var i = 0; i &lt; data.nrows; ++i) {
			tmp.push(new Float64Array(data[i]));
		}
		objectBuffer = new MathWorkers.Matrix();
		objectBuffer.setMatrix(tmp);
		that.emit(data.tag);
	};

	/**
	 * Gather Vector parts from workers into a new Vector stored in the
	 * Coordinator objectBuffer.
	 * Emits the message tag event.
	 *
	 * @param data {!Object} message data
	 * @private
	 */
	var handleGatherVector = function(data) {
		// Gather the vector parts from each worker
        if (nWorkersReported == 0) {
            objectBuffer = new MathWorkers.Vector(data.len);
        }
        var tmpArray = new Float64Array(data.vectorPart);
        var offset = data.offset;
        for (var i = 0; i &lt; tmpArray.length; ++i) {
            objectBuffer.array[offset + i] = tmpArray[i];
        }

		nWorkersReported += 1;
		if (nWorkersReported == global.nWorkers) {
			if (data.rebroadcast) {
				that.sendVectorToWorkers(objectBuffer, data.tag);
			} else {
				// emit
				that.emit(data.tag);
			}
			// reset
			nWorkersReported = 0;
		}
	};

	/**
	 * Gather Matrix rows from workers into a new Matrix stored in the
	 * Coordinator objectBuffer.
	 * Emits the message tag event.
	 *
	 * @param data {!Object} message data
	 * @private
	 */
	var handleGatherMatrixRows = function(data) {
		// Gather the matrix rows from each worker
        var offset = data.offset;
        if (nWorkersReported == 0) {
            objectBuffer = new MathWorkers.Matrix(data.nrows, data.ncols);
        }
        for (var i = 0; i &lt; data.nrowsPart; ++i) {
			objectBuffer.array[offset + i] = new Float64Array(data[i]);
		}

		nWorkersReported += 1;
		if (nWorkersReported == global.nWorkers) {
			// build the full vector and save to buffer
			if (data.rebroadcast) {
				that.sendMatrixToWorkers(objectBuffer, data.tag);
			} else {
				// emit
				that.emit(data.tag);
			}
			//reset
			nWorkersReported = 0;
		}
	};

	/**
	 * Gather Matrix columns from workers into a new Matrix stored in the
	 * Coordinator objectBuffer.
	 * Emits the message tag event.
	 *
	 * @param data {!Object} message data
	 * @private
	 */
    var handleGatherMatrixColumns = function(data) {
        // Gather the matrix columns from each worker
        var i, k;
        if (nWorkersReported == 0) {
            objectBuffer = new MathWorkers.Matrix(data.nrows, data.ncols);
        }

        // array in data is transposed
        var tmpArray;
        var offsetk;
        for (k = 0, offsetk = data.offset; k &lt; data.nrowsPart; ++k, ++offsetk) {
            tmpArray = new Float64Array(data[k]);
            for (i = 0; i &lt; tmpArray.length; ++i) {
                objectBuffer.array[i][offsetk] = tmpArray[i];
            }
        }

        nWorkersReported += 1;
        if (nWorkersReported == global.nWorkers) {
            if (data.rebroadcast) {
                that.sendMatrixToWorkers(objectBuffer, data.tag);
            } else {
                // emit
                that.emit(data.tag);
            }
            //reset
            nWorkersReported = 0;
        }
    };

	/**
	 * Sum reduction for a Vector. Stores the full sum in the objectBuffer.
	 * Emits the message tag event.
	 *
	 * @param data {!Object}
	 * @private
	 */
    var handleVectorSum = function(data) {
        if (nWorkersReported == 0) {
            objectBuffer = data.tot;
        } else {
            objectBuffer += data.tot;
        }
        nWorkersReported += 1;
        if (nWorkersReported == global.nWorkers) {
            if (data.rebroadcast) {
                // rebroadcast the result back to the workers
                that.sendDataToWorkers(objectBuffer, data.tag);
            } else {
                // save result to buffer and emit to the browser-side coordinator
                that.emit(data.tag);
            }
            // reset for next message
            nWorkersReported = 0;
        }
    };

	/**
	 * Product reduction for a Vector. Stores the full product in the objectBuffer.
	 * Emits the message tag event.
	 *
	 * @param data {!Object}
	 * @private
	 */
	var handleVectorProduct = function(data) {
        if (nWorkersReported == 0) {
            objectBuffer = data.tot;
        } else {
            objectBuffer *= data.tot;
        }
		nWorkersReported += 1;
		if (nWorkersReported == global.nWorkers) {
			if (data.rebroadcast) {
				// rebroadcast the result back to the workers
				that.sendDataToWorkers(objectBuffer, data.tag);
			} else {
				// save result to buffer and emit to the browser-side coordinator
				that.emit(data.tag);
			}
			// reset for next message
			nWorkersReported = 0;
		}
	};

};
MathWorkers.Coordinator.prototype = new EventEmitter();

// Copyright 2014 Adrian W. Lange

/**
 * MathWorker for worker-side interface.
 * Manages computations and message passing for a web worker in the worker pool.
 *
 * @constructor
 * @mixes EventEmitter
 * @memberof MathWorkers
 */
MathWorkers.MathWorker = function() {

	/**
	 * Buffer for data received from the coordinator
	 *
	 * @member {Object}
	 * @private
	 */
 	var objectBuffer = {};

	/**
	 * An object mapping an event tag key to a registered callback value
	 *
	 * @member {Object}
	 * @private
	 */
 	var triggers = {};

	/**
	 * Retrieve the id number of the MathWorker
	 *
	 * @returns {number} the id of the MathWorker
	 */
 	this.getId = function() {
 		return global.myWorkerId;
 	};

	/**
	 * Retrieve the size (number of workers) in the worker pool
	 *
	 * @returns {number} the size of the worker pool
	 */
 	this.getNumWorkers = function() {
 		return global.nWorkers;
 	};

	/**
	 * Fetches the object buffer contents.
	 * After a message from the coordinator is received, the object
	 * buffer is typically populated with data.
	 *
	 * @returns {Object}
	 */
	this.getBuffer = function() {
		return objectBuffer;
	};

	/**
	 * Register an event with a callback to be executed when the coordinator triggers the event
	 *
	 * @param {!string} tag the unique label for the event being registered
	 * @param {function} callback the callback function to be registered
	 */
	this.on = function(tag, callback) {
		if (global.logLevel > 2) {
			console.log("registering trigger: " + tag);
		}
		triggers[tag] = [callback];
	};

	/**
	 * Send data to the coordinator
	 *
	 * @param {Object} data JSON-serializable data to be sent to coordinator
	 * @param {!string} tag message tag
	 */
 	this.sendDataToCoordinator = function(data, tag) {
 		self.postMessage({handle: "_sendData", id: global.myWorkerId, tag: tag, data: data});
 	};

	/**
	 * Send a Vector to the coordinator
	 *
	 * @param {MathWorkers.Vector} vec the Vector to be sent
	 * @param {!string} tag message tag
	 */
    this.sendVectorToCoordinator = function(vec, tag) {
        // only id 0 does the sending actually
        if (global.myWorkerId == 0) {
            self.postMessage({handle: "_vectorSendToCoordinator", tag: tag,
                vectorBuffer: vec.array.buffer}, [vec.array.buffer]);
        }
    };

	/**
	 * Send a Matrix to the coordinator
	 *
	 * @param {MathWorkers.Matrix} mat the Matrix to be sent
	 * @param {!string} tag message tag
	 */
    this.sendMatrixToCoordinator = function(mat, tag) {
        // only id 0 does the sending actually
        if (id == 0) {
            var matObject = {handle: "_matrixSendToCoordinator", tag: tag, nrows: mat.nrows};
            var matBufferList = [];
            for (var i = 0; i &lt; mat.nrows; ++i) {
                matObject[i] = mat.array[i].buffer;
                matBufferList.push(mat.array[i].buffer);
            }
            self.postMessage(matObject, matBufferList);
        }
    };

	/**
	 * onmessage event router.
	 * Route the event appropriately based on the event data.
	 *
	 * @param {Object} event web worker event object
	 * @private
	 */
	self.onmessage = function(event) {
		var data = event.data;
		switch (data.handle) {
			case "_init":
				handleInit(data);
				break;
			case "_trigger":
				handleTrigger(data);
				break;
			case "_broadcastData":
				handleBroadcastData(data);
				break;
			case "_broadcastVector":
				handleBroadcastVector(data);
				break;
			case "_broadcastMatrix":
				handleBroadcastMatrix(data);
				break;
 			default:
 				console.error("Invalid MathWorker handle: " + data.handle);
 		}
 	};

	/**
	 * MathWorker initialization. This message is received upon the coordinator creating this worker for
	 * the worker pool in MathWorkers.global.createPool().
	 * Sets various internal variables for this worker, and then sends a ready message to the coordinator.
	 *
	 * @param {Object} data message data
	 * @private
	 */
 	var handleInit = function(data) {
        global.myWorkerId = data.id;
        global.nWorkers = data.nWorkers;
        global.unrollLoops = data.unrollLoops;
        global.logLevel = data.logLevel;
 		if (global.logLevel > 2) {
            console.log("Initialized MathWorker: " + global.myWorkerId + " of " + global.nWorkers + " workers.");
        }
        self.postMessage({handle: "_workerReady"});
 	};

	/**
	 * When the coordinator issues a trigger message, execute the registered callback corresponding to the message tag.
	 *
	 * @param {Object} data message data
	 * @param {Object} [obj] optional object to pass as an argument to the callback
	 * @private
	 */
 	var handleTrigger = function(data, obj) {
		if (triggers[data.tag]) {
			triggers[data.tag] = triggers[data.tag] || [];
			var args = data.data || obj || [];
			triggers[data.tag].forEach( function(fn) {
				fn.call(this, args);
			});
		} else {
			console.error("Unregistered trigger tag: " + data.tag);
		}
 	};

	/**
	 * Place broadcast data from coordinator into the objectBuffer.
	 * Then, trigger the corresponding event.
	 *
	 * @param {Object} data message data
	 * @private
	 */
 	var handleBroadcastData = function(data) {
 		objectBuffer = data.data;
 		handleTrigger(data);
 	};


	/**
	 * Place broadcast Vector from coordinator into the objectBuffer.
	 * Then, trigger the corresponding event.
	 *
	 * @param {Object} data message data
	 * @private
	 */
 	var handleBroadcastVector = function(data) {
 		objectBuffer = MathWorkers.Vector.fromArray(new Float64Array(data.vec));
 		handleTrigger(data, objectBuffer);
 	};

	/**
	 * Place broadcast Matrix from coordinator into the objectBuffer.
	 * Then, trigger the corresponding event.
	 *
	 * @param {Object} data message data
	 * @private
	 */
 	var handleBroadcastMatrix = function(data) {
 		var tmp = [];
		for (var i = 0; i &lt; data.nrows; ++i) {
			tmp.push(new Float64Array(data[i]));
		}
		objectBuffer = new MathWorkers.Matrix();
		objectBuffer.setMatrix(tmp);
 		handleTrigger(data, objectBuffer);
 	};
};
MathWorkers.MathWorker.prototype = new EventEmitter();


/*
 * MathWorker internal static-like communication functions
 */

/**
 * Prepare and send a Vector to the coordinator via message passing
 *
 * @param {!Float64Array} vec the Vector to be gathered. Each worker is responsible for a different section.
 * @param {!number} totalLength the total length of the gathered Vector
 * @param {!number} offset the offset to use in the gather for this worker's Vector section
 * @param {!string} tag message tag
 * @param {boolean} [rebroadcast] If true, have the coordinator broadcast the gathered Vector back to all workers,
 *                                stored in their objectBuffers. Otherwise, the gathered Vector remains in the
 *                                coordinator objectBuffer.
 * @ignore
 */
MathWorkers.MathWorker.gatherVector = function(vec, totalLength, offset, tag, rebroadcast) {
    rebroadcast = rebroadcast || false;
    self.postMessage({handle: "_gatherVector", tag: tag, id: global.myWorkerId, rebroadcast: rebroadcast,
        len: totalLength, offset: offset, vectorPart: vec.buffer}, [vec.buffer]);
};

/**
 * Prepare and send a Matrix by rows to the coordinator via message passing
 *
 * @param {!Array.&lt;Float64Array>} mat the Matrix to be gathered by rows. Each worker is responsible for different rows.
 * @param {!number} totalRows the total number of rows in the gathered Matrix
 * @param {!number} offset the row offset to use in the gather for this worker's Matrix rows
 * @param {!string} tag message tag
 * @param {boolean} rebroadcast If true, have the coordinator broadcast the gathered Matrix back to all workers,
 *                              stored in their objectBuffers. Otherwise, the gathered Matrix remains in the
 *                              coordinator objectBuffer.
 * @ignore
 */
MathWorkers.MathWorker.gatherMatrixRows = function(mat, totalRows, offset, tag, rebroadcast) {
    rebroadcast = rebroadcast || false;
    var matObject = {handle: "_gatherMatrixRows", tag: tag, id: global.myWorkerId, rebroadcast: rebroadcast,
        nrows: totalRows, ncols: mat[0].length, nrowsPart: mat.length, offset: offset};
    var matBufferList = [];
    for (var i = 0; i &lt; mat.length; ++i) {
        matObject[i] = mat[i].buffer;
        matBufferList.push(mat[i].buffer);
    }
    self.postMessage(matObject, matBufferList);
};

/**
 * Prepare and send a Matrix by columns to the coordinator via message passing
 *
 * @param {!Array.&lt;Float64Array>} mat the Matrix to be gathered by columns. Each worker is responsible for different columns.
 * @param {!number} totalRows the total number of rows in the gathered Matrix
 * @param {!number} totalCols the total number of columns in the gathered Matrix
 * @param {!number} offset the column offset to use in the gather for this worker's Matrix columns
 * @param {!string} tag message tag
 * @param {boolean} rebroadcast If true, have the coordinator broadcast the gathered Matrix back to all workers,
 *                              stored in their objectBuffers. Otherwise, the gathered Matrix remains in the
 *                              coordinator objectBuffer.
 * @ignore
 */
MathWorkers.MathWorker.gatherMatrixColumns = function(mat, totalRows, totalCols, offset, tag, rebroadcast) {
    rebroadcast = rebroadcast || false;
    var matObject = {handle: "_gatherMatrixColumns", tag: tag, id: global.myWorkerId, rebroadcast: rebroadcast,
        nrows: totalRows, ncols: totalCols, nrowsPart: mat.length, offset: offset};
    var matBufferList = [];
    for (var i = 0; i &lt; mat.length; ++i) {
        matObject[i] = mat[i].buffer;
        matBufferList.push(mat[i].buffer);
    }
    self.postMessage(matObject, matBufferList);
};

/**
 * Prepare and send a number total for a Vector reduction summation
 *
 * @param {!number} tot this worker's sum to be reduced
 * @param {!string} tag message tag
 * @param {boolean} rebroadcast If true, have the coordinator broadcast the reduced sum back to all workers,
 *                              stored in their objectBuffers. Otherwise, the reduced sum remains in the
 *                              coordinator objectBuffer.
 * @ignore
 */
MathWorkers.MathWorker.reduceVectorSum = function(tot, tag, rebroadcast) {
    rebroadcast = rebroadcast || false;
    self.postMessage({handle: "_vectorSum", tag: tag, rebroadcast: rebroadcast, tot: tot});
};


/**
 * Prepare and send a number total for a Vector reduction product
 *
 * @param {!number} tot this worker's product to be reduced
 * @param {!string} tag message tag
 * @param {boolean} rebroadcast If true, have the coordinator broadcast the reduced product back to all workers,
 *                              stored in their objectBuffers. Otherwise, the reduced product remains in the
 *                              coordinator objectBuffer.
 * @ignore
 */
MathWorkers.MathWorker.reduceVectorProduct = function(tot, tag, rebroadcast) {
    rebroadcast = rebroadcast || false;
    self.postMessage({handle: "_vectorProduct", tag: tag, rebroadcast: rebroadcast, tot: tot});
};


// Copyright 2014 Adrian W. Lange

/**
 * Vector class.
 * A wrapper around a Float64Array with several vector operations defined, including worker
 * parallelized operations.
 *
 * @param {number} [size] the length of the Vector being constructed. If not provided or less than 1,
 *                        a Vector object is still created but with a null array.
 * @constructor
 * @memberof MathWorkers
 */
MathWorkers.Vector = function(size) {

    /**
     * The underlying Float64Array for a Vector
     *
     * @member {Float64Array}
     */
    this.array = null;

    /**
     * The size of the Vector's Float64Array
     *
     * @member {number}
     */
    this.length = size || 0;
    if (size > 0) {
        this.array = new Float64Array(size);
    }
};

/**
 * Create a new Vector object from a provided array of numbers. Deep copies the array.
 *
 * @param {!Array.&lt;number> | !Float64Array} arr the number array to be copied
 * @returns {MathWorkers.Vector} the new Vector object
 * @memberof MathWorkers.Vector
 */
MathWorkers.Vector.fromArray = function(arr) {
    MathWorkers.util.checkArray(arr);
    var vec = new MathWorkers.Vector(arr.length);
    for (var i = 0, ni = arr.length; i &lt; ni; ++i) {
        vec.array[i] = arr[i];
    }
    return vec;
};

/**
 * Assign the underlying Float64Array for this Vector
 *
 * @param {!Float64Array} arr the Float64Array to be assigned to this Vector object
 * @memberof MathWorkers.Vector
 */
MathWorkers.Vector.prototype.setVector = function(arr) {
    MathWorkers.util.checkFloat64Array(arr);
    this.array = arr;
    this.length = arr.length;
};

/**
 * Create a new Vector object populated with all zero values
 *
 * @param {!number} size the length of the Vector to be created
 * @returns {MathWorkers.Vector} the new zeroed Vector
 * @memberof MathWorkers.Vector
 */
MathWorkers.Vector.zeroes = function(size) {
    var vec = new MathWorkers.Vector(size);
    for (var i = 0; i &lt; size; ++i) {
        vec.array[i] = 0.0;
    }
    return vec;
};

/**
 * Create a new Vector object populated with random values between 0 and 1
 *
 * @param {!number} size the length of the Vector to be created
 * @returns {MathWorkers.Vector} the new random Vector
 * @memberof MathWorkers.Vector
 */
MathWorkers.Vector.randomVector = function(size) {
    var vec = new MathWorkers.Vector(size);
    for (var i = 0; i &lt; size; ++i) {
        vec.array[i] = Math.random();
    }
    return vec;
};

/**
 * Convert the Vector data into a printable string
 *
 * @returns {string} the string representation of the Vector
 * @memberof MathWorkers.Vector
 */
MathWorkers.Vector.prototype.toString = function() {
    var str = "[";
    for (var i = 0; i &lt; this.length - 1; ++i) {
        str += this.array[i] + ", ";
    }
    return str + this.array[this.length-1] + "]";
};

/**
 * Compute the sum of all elements in the Vector
 *
 * @returns {number} the sum of all elements
 * @memberof MathWorkers.Vector
 */
MathWorkers.Vector.prototype.sum = function() {
    var result = 0.0;
    var i;
    var ni = this.length;
    if (global.unrollLoops) {
        var ni3 = ni - 3;
        for (i = 0; i &lt; ni3; i += 4) {
            result += this.array[i] + this.array[i+1] + this.array[i+2] + this.array[i+3];
        }
        for (; i &lt; ni; ++i) {
            result += this.array[i];
        }
    } else {
        for (i = 0; i &lt; ni; ++i) {
            result += this.array[i];
        }
    }
    return result;
};

/**
 * Compute the product of all elements in the Vector
 *
 * @returns {number} the product of all elements
 * @memberof MathWorkers.Vector
 */
MathWorkers.Vector.prototype.product = function() {
    var result = 1.0;
    var i;
    var ni = this.length;
    if (global.unrollLoops) {
        var ni3 = ni - 3;
        for (i = 0; i &lt; ni3; i += 4) {
            result *= this.array[i] * this.array[i+1] * this.array[i+2] * this.array[i+3];
        }
        for (; i &lt; ni; ++i) {
            result *= this.array[i];
        }
    } else {
        for (i = 0; i &lt; ni; ++i) {
            result *= this.array[i];
        }
    }
    return result;
};

/**
 * Add this Vector to another (element-wise).
 *
 * @param {MathWorkers.Vector} w the Vector to add with this Vector
 * @returns {MathWorkers.Vector} the element-wise sum of this Vector with w
 * @memberof MathWorkers.Vector
 */
MathWorkers.Vector.prototype.plus = function(w) {
    MathWorkers.util.checkVectors(this, w);
    var result = new MathWorkers.Vector(this.length);
    var i;
    var ni = this.length;
    if (global.unrollLoops) {
        var ni3 = ni - 3;
        for (i = 0; i &lt; ni3; i += 4) {
            result.array[i] = this.array[i] + w.array[i];
            result.array[i+1] = this.array[i+1] + w.array[i+1];
            result.array[i+2] = this.array[i+2] + w.array[i+2];
            result.array[i+3] = this.array[i+3] + w.array[i+3];
        }
        for (; i &lt; ni; ++i) {
            result.array[i] = this.array[i] + w.array[i];
        }
    } else {
        for (i = 0; i &lt; ni; ++i) {
            result.array[i] = this.array[i] + w.array[i];
        }
    }
    return result;
};

/**
 * Subtract another Vector from this Vector (element-wise).
 *
 * @param {MathWorkers.Vector} w the Vector to subtract from this Vector
 * @returns {MathWorkers.Vector} the element-wise difference of w from this Vector
 * @memberof MathWorkers.Vector
 */
MathWorkers.Vector.prototype.minus = function(w) {
    MathWorkers.util.checkVectors(this, w);
    var result = new MathWorkers.Vector(this.length);
    var i;
    var ni = this.length;
    if (global.unrollLoops) {
        var ni3 = ni - 3;
        for (i = 0; i &lt; ni3; i += 4) {
            result.array[i] = this.array[i] - w.array[i];
            result.array[i+1] = this.array[i+1] - w.array[i+1];
            result.array[i+2] = this.array[i+2] - w.array[i+2];
            result.array[i+3] = this.array[i+3] - w.array[i+3];
        }
        for (; i &lt; ni; ++i) {
            result.array[i] = this.array[i] - w.array[i];
        }
    } else {
        for (i = 0; i &lt; ni; ++i) {
            result.array[i] = this.array[i] - w.array[i];
        }
    }
    return result;
};

/**
 * Multiply this Vector with another (element-wise).
 *
 * @param {MathWorkers.Vector} w the Vector to multiply with this Vector
 * @returns {MathWorkers.Vector} the element-wise product of this Vector with w
 * @memberof MathWorkers.Vector
 */
MathWorkers.Vector.prototype.times = function(w) {
    MathWorkers.util.checkVectors(this, w);
    var result = new MathWorkers.Vector(this.length);
    var i;
    var ni = this.length;
    if (global.unrollLoops) {
        var ni3 = ni - 3;
        for (i = 0; i &lt; ni3; i += 4) {
            result.array[i] = this.array[i] * w.array[i];
            result.array[i+1] = this.array[i+1] * w.array[i+1];
            result.array[i+2] = this.array[i+2] * w.array[i+2];
            result.array[i+3] = this.array[i+3] * w.array[i+3];
        }
        for (; i &lt; ni; ++i) {
            result.array[i] = this.array[i] * w.array[i];
        }
    } else {
        for (i = 0; i &lt; ni; ++i) {
            result.array[i] = this.array[i] * w.array[i];
        }
    }
    return result;
};

/**
 * Divide this Vector by another (element-wise).
 *
 * @param {MathWorkers.Vector} w the Vector to divide this Vector by
 * @returns {MathWorkers.Vector} the element-wise quotient of this Vector by w
 * @memberof MathWorkers.Vector
 */
MathWorkers.Vector.prototype.divide = function(w) {
    MathWorkers.util.checkVectors(this, w);
    var result = new MathWorkers.Vector(this.length);
    var i;
    var ni = this.length;
    if (global.unrollLoops) {
        var ni3 = ni - 3;
        for (i = 0; i &lt; ni3; i += 4) {
            result.array[i] = this.array[i] / w.array[i];
            result.array[i+1] = this.array[i+1] / w.array[i+1];
            result.array[i+2] = this.array[i+2] / w.array[i+2];
            result.array[i+3] = this.array[i+3] / w.array[i+3];
        }
        for (; i &lt; ni; ++i) {
            result.array[i] = this.array[i] / w.array[i];
        }
    } else {
        for (i = 0; i &lt; ni; ++i) {
            result.array[i] = this.array[i] / w.array[i];
        }
    }
    return result;
};

/**
 * Multiply all elements of this Vector by a scalar.
 *
 * @param {!number} alpha the scalar to multiply by
 * @returns {MathWorkers.Vector} the scaled Vector
 * @memberof MathWorkers.Vector
 */
MathWorkers.Vector.prototype.scale = function(alpha) {
    MathWorkers.util.checkNumber(alpha);
    var result = new MathWorkers.Vector(this.length);
    var i;
    var ni = this.length;
    if (global.unrollLoops) {
        var ni3 = ni - 3;
        for (i = 0; i &lt; ni3; i += 4) {
            result.array[i] = this.array[i] * alpha;
            result.array[i+1] = this.array[i+1] * alpha;
            result.array[i+2] = this.array[i+2] * alpha;
            result.array[i+3] = this.array[i+3] * alpha;
        }
        for (; i &lt; ni; ++i) {
            result.array[i] = this.array[i] * alpha;
        }
    } else {
        for (i = 0; i &lt; ni; ++i) {
            result.array[i] = this.array[i] * alpha;
        }
    }
    return result;
};

/**
 * Apply (or, map) a function onto each value in this Vector. The function must take a number as its argument and
 * return a number. That is, the function must map a number to a number.
 *
 * @param {!function} fn the function to be applied to each element of the Vector
 * @returns {MathWorkers.Vector} the mapped Vector
 * @memberof MathWorkers.Vector
 */
MathWorkers.Vector.prototype.apply = function(fn) {
    MathWorkers.util.checkFunction(fn);
    var result = new MathWorkers.Vector(this.length);
    var i;
    var ni = this.length;
    if (global.unrollLoops) {
        var ni3 = ni - 3;
        for (i = 0; i &lt; ni3; i += 4) {
            result.array[i] = fn(this.array[i]);
            result.array[i+1] = fn(this.array[i+1]);
            result.array[i+2] = fn(this.array[i+2]);
            result.array[i+3] = fn(this.array[i+3]);
        }
        for (; i &lt; ni; ++i) {
            result.array[i] = fn(this.array[i]);
        }
    } else {
        for (i = 0; i &lt; ni; ++i) {
            result.array[i] = fn(this.array[i]);
        }
    }
    return result;
};

/**
 * Compute the dot product of this Vector with another Vector.
 *
 * @param {!MathWorkers.Vector} w the other Vector to be dotted with this Vector
 * @returns {number} the resulting dot product value
 * @memberof MathWorkers.Vector
 */
MathWorkers.Vector.prototype.dotVector = function(w) {
    MathWorkers.util.checkVectors(this, w);
    var i;
    var ni = this.length;
    var tot = 0.0;
    if (global.unrollLoops) {
        var ni3 = ni - 3;
        for (i = 0; i &lt; ni3; i += 4) {
            tot += this.array[i] * w.array[i]
                + this.array[i+1] * w.array[i+1]
                + this.array[i+2] * w.array[i+2]
                + this.array[i+3] * w.array[i+3];
        }
        for (; i &lt; ni; ++i) {
            tot += this.array[i] * w.array[i];
        }
    } else {
        for (i = 0; i &lt; ni; ++i) {
            tot += this.array[i] * w.array[i];
        }
    }
    return tot;
};

/**
 * Compute the vector-matrix product of this Vector with a Matrix.
 * It is assumed that this Vector is transposed such that it is a row vector.
 * The ordering is such that this Vector v A and the Matrix is A: v.A
 *
 * @param {!MathWorkers.Matrix} A the matrix to multiply with
 * @returns {MathWorkers.Vector} the resulting Vector of the vector-matrix product
 * @memberof MathWorkers.Vector
 */
MathWorkers.Vector.prototype.dotMatrix = function(A) {
    MathWorkers.util.checkVectorMatrix(this, A);
    var i, j, tot;
    var ni = A.ncols;
    var nj = this.length;
    var w = new MathWorkers.Vector(ni);
    if (global.unrollLoops) {
        var nj3 = nj - 3;
        for (i = 0; i &lt; ni; ++i) {
            tot = 0.0;
            for (j = 0; j &lt; nj3; j += 4) {
                tot += this.array[j] * A.array[j][i]
                    + this.array[j+1] * A.array[j+1][i]
                    + this.array[j+2] * A.array[j+2][i]
                    + this.array[j+3] * A.array[j+3][i];
            }
            for (; j &lt; nj; ++j) {
                tot += this.array[j] * A.array[j][i];
            }
            w.array[i] = tot;
        }
    } else {
        for (i = 0; i &lt; ni; ++i) {
            tot = 0.0;
            for (j = 0; j &lt; nj; ++j) {
                tot += this.array[j] * A.array[j][i];
            }
            w.array[i] = tot;
        }
    }
    return w;
};


// Copyright 2014 Adrian W. Lange

/*
 * Parallel worker versions of the Vector methods
 */

/**
 * Compute the sum of all elements in the Vector in parallel
 *
 * @param {!string} tag message tag
 * @param {boolean} [rebroadcast] If true, the coordinator broadcasts the result back to the workers.
 * @memberof MathWorkers.Vector
 */
MathWorkers.Vector.prototype.workerSum = function(tag, rebroadcast) {
    MathWorkers.util.checkNullOrUndefined(tag);
    var lb = MathWorkers.util.loadBalance(this.length);
    var tot = 0.0;
    var i;
    if (global.unrollLoops) {
        var ni3 = lb.ito - 3;
        for (i = lb.ifrom; i &lt; ni3; ++i) {
            tot += this.array[i] + this.array[i+1] + this.array[i+2] + this.array[i+3];
        }
        for (; i &lt; lb.ito; ++i) {
            tot += this.array[i];
        }
    } else {
        for (i = lb.ifrom; i &lt; lb.ito; ++i) {
            tot += this.array[i];
        }
    }
    MathWorkers.MathWorker.reduceVectorSum(tot, tag, rebroadcast);
};

/**
 * Compute the product of all elements in the Vector in parallel
 *
 * @param {!string} tag message tag
 * @param {boolean} [rebroadcast] If true, the coordinator broadcasts the result back to the workers.
 * @memberof MathWorkers.Vector
 */
MathWorkers.Vector.prototype.workerProduct = function(tag, rebroadcast) {
    MathWorkers.util.checkNullOrUndefined(tag);
    var lb = MathWorkers.util.loadBalance(this.length);
    var tot = 1.0;
    var i;
    if (global.unrollLoops) {
        var ni3 = lb.ito - 3;
        for (i = lb.ifrom; i &lt; ni3; ++i) {
            tot *= this.array[i] * this.array[i+1] * this.array[i+2] * this.array[i+3];
        }
        for (; i &lt; lb.ito; ++i) {
            tot *= this.array[i];
        }
    } else {
        for (i = lb.ifrom; i &lt; lb.ito; ++i) {
            tot *= this.array[i];
        }
    }
    MathWorkers.MathWorker.reduceVectorProduct(tot, tag, rebroadcast);
};


/**
 * Add this Vector to another (element-wise) in parallel.
 *
 * @param {!MathWorkers.Vector} w the Vector to add with this Vector
 * @param {!string} tag message tag
 * @param {boolean} [rebroadcast] If true, the coordinator broadcasts the result back to the workers.
 * @memberof MathWorkers.Vector
 */
MathWorkers.Vector.prototype.workerPlus = function(w, tag, rebroadcast) {
    MathWorkers.util.checkVectors(this, w);
    MathWorkers.util.checkNullOrUndefined(tag);
    var lb = MathWorkers.util.loadBalance(this.length);
    var x = new Float64Array(lb.ito - lb.ifrom);
    var offset = 0;
    var i;
    if (global.unrollLoops) {
        var ni3 = lb.ito - 3;
        for (i = lb.ifrom; i &lt; ni3; ++i) {
            x[offset++] = this.array[i] + w.array[i];
            x[offset++] = this.array[i+1] + w.array[i+1];
            x[offset++] = this.array[i+2] + w.array[i+2];
            x[offset++] = this.array[i+3] + w.array[i+3];
        }
        for (; i &lt; lb.ito; ++i) {
            x[offset++] = this.array[i] + w.array[i];
        }
    } else {
        for (i = lb.ifrom; i &lt; lb.ito; ++i) {
            x[offset++] = this.array[i] + w.array[i];
        }
    }
    MathWorkers.MathWorker.gatherVector(x, this.length, lb.ifrom, tag, rebroadcast);
};

/**
 * Subtract another Vector from this Vector (element-wise) in parallel.
 *
 * @param {!MathWorkers.Vector} w the Vector to subtract from this Vector
 * @param {!string} tag message tag
 * @param {boolean} [rebroadcast] If true, the coordinator broadcasts the result back to the workers.
 * @memberof MathWorkers.Vector
 */
MathWorkers.Vector.prototype.workerMinus = function(w, tag, rebroadcast) {
    MathWorkers.util.checkVectors(this, w);
    MathWorkers.util.checkNullOrUndefined(tag);
    var lb = MathWorkers.util.loadBalance(this.length);
    var x = new Float64Array(lb.ito - lb.ifrom);
    var offset = 0;
    var i;
    if (global.unrollLoops) {
        var ni3 = lb.ito - 3;
        for (i = lb.ifrom; i &lt; ni3; ++i) {
            x[offset++] = this.array[i] - w.array[i];
            x[offset++] = this.array[i+1] - w.array[i+1];
            x[offset++] = this.array[i+2] - w.array[i+2];
            x[offset++] = this.array[i+3] - w.array[i+3];
        }
        for (; i &lt; lb.ito; ++i) {
            x[offset++] = this.array[i] - w.array[i];
        }
    } else {
        for (i = lb.ifrom; i &lt; lb.ito; ++i) {
            x[offset++] = this.array[i] - w.array[i];
        }
    }
    MathWorkers.MathWorker.gatherVector(x, this.length, lb.ifrom, tag, rebroadcast);
};

/**
 * Multiply this Vector with another (element-wise) in parallel.
 *
 * @param {!MathWorkers.Vector} w the Vector to multiply with this Vector
 * @param {!string} tag message tag
 * @param {boolean} [rebroadcast] If true, the coordinator broadcasts the result back to the workers.
 * @memberof MathWorkers.Vector
 */
MathWorkers.Vector.prototype.workerTimes = function(w, tag, rebroadcast) {
    MathWorkers.util.checkVectors(this, w);
    MathWorkers.util.checkNullOrUndefined(tag);
    var lb = MathWorkers.util.loadBalance(this.length);
    var x = new Float64Array(lb.ito - lb.ifrom);
    var offset = 0;
    var i;
    if (global.unrollLoops) {
        var ni3 = lb.ito - 3;
        for (i = lb.ifrom; i &lt; ni3; ++i) {
            x[offset++] = this.array[i] * w.array[i];
            x[offset++] = this.array[i+1] * w.array[i+1];
            x[offset++] = this.array[i+2] * w.array[i+2];
            x[offset++] = this.array[i+3] * w.array[i+3];
        }
        for (; i &lt; lb.ito; ++i) {
            x[offset++] = this.array[i] * w.array[i];
        }
    } else {
        for (i = lb.ifrom; i &lt; lb.ito; ++i) {
            x[offset++] = this.array[i] * w.array[i];
        }
    }
    MathWorkers.MathWorker.gatherVector(x, this.length, lb.ifrom, tag, rebroadcast);
};

/**
 * Divide this Vector to another (element-wise) in parallel.
 *
 * @param {!MathWorkers.Vector} w the Vector to divide this Vector by
 * @param {!string} tag message tag
 * @param {boolean} [rebroadcast] If true, the coordinator broadcasts the result back to the workers.
 * @memberof MathWorkers.Vector
 */
MathWorkers.Vector.prototype.workerDivide = function(w, tag, rebroadcast) {
    MathWorkers.util.checkVectors(this, w);
    MathWorkers.util.checkNullOrUndefined(tag);
    var lb = MathWorkers.util.loadBalance(this.length);
    var x = new Float64Array(lb.ito - lb.ifrom);
    var offset = 0;
    var i;
    if (global.unrollLoops) {
        var ni3 = lb.ito - 3;
        for (i = lb.ifrom; i &lt; ni3; ++i) {
            x[offset++] = this.array[i] / w.array[i];
            x[offset++] = this.array[i+1] / w.array[i+1];
            x[offset++] = this.array[i+2] / w.array[i+2];
            x[offset++] = this.array[i+3] / w.array[i+3];
        }
        for (; i &lt; lb.ito; ++i) {
            x[offset++] = this.array[i] / w.array[i];
        }
    } else {
        for (i = lb.ifrom; i &lt; lb.ito; ++i) {
            x[offset++] = this.array[i] / w.array[i];
        }
    }
    MathWorkers.MathWorker.gatherVector(x, this.length, lb.ifrom, tag, rebroadcast);
};

/**
 * Multiply all elements of this Vector by a scalar in parallel.
 *
 * @param {!number} alpha the scalar to multiply by
 * @param {!string} tag message tag
 * @param {boolean} [rebroadcast] If true, the coordinator broadcasts the result back to the workers.
 * @memberof MathWorkers.Vector
 */
MathWorkers.Vector.prototype.workerScale = function(alpha, tag, rebroadcast) {
    MathWorkers.util.checkNumber(alpha);
    MathWorkers.util.checkNullOrUndefined(tag);
    var lb = MathWorkers.util.loadBalance(this.length);
    var x = new Float64Array(lb.ito - lb.ifrom);
    var offset = 0;
    var i;
    if (global.unrollLoops) {
        var ni3 = lb.ito - 3;
        for (i = lb.ifrom; i &lt; ni3; ++i) {
            x[offset++] = this.array[i] * alpha;
            x[offset++] = this.array[i+1] * alpha;
            x[offset++] = this.array[i+2] * alpha;
            x[offset++] = this.array[i+3] * alpha;
        }
        for (; i &lt; lb.ito; ++i) {
            x[offset++] = this.array[i] * alpha;
        }
    } else {
        for (i = lb.ifrom; i &lt; lb.ito; ++i) {
            x[offset++] = this.array[i] * alpha;
        }
    }
    MathWorkers.MathWorker.gatherVector(x, this.length, lb.ifrom, tag, rebroadcast);
};

/**
 * Apply (or, map) a function onto each value in this Vector in parallel. The function must take a number as its
 * argument and return a number. That is, the function must map a number to a number.
 *
 * @param {!function} fn the function to be applied to each element of this Vector
 * @param {!string} tag message tag
 * @param {boolean} [rebroadcast] If true, the coordinator broadcasts the result back to the workers.
 * @memberof MathWorkers.Vector
 */
MathWorkers.Vector.prototype.workerApply = function(fn, tag, rebroadcast) {
    MathWorkers.util.checkFunction(fn);
    MathWorkers.util.checkNullOrUndefined(tag);
    var lb = MathWorkers.util.loadBalance(this.length);
    var x = new Float64Array(lb.ito - lb.ifrom);
    var offset = 0;
    var i;
    if (global.unrollLoops) {
        var ni3 = lb.ito - 3;
        for (i = lb.ifrom; i &lt; ni3; ++i) {
            x[offset++] = fn(this.array[i]);
            x[offset++] = fn(this.array[i+1]);
            x[offset++] = fn(this.array[i+2]);
            x[offset++] = fn(this.array[i+3]);
        }
        for (; i &lt; lb.ito; ++i) {
            x[offset++] = fn(this.array[i]);
        }
    } else {
        for (i = lb.ifrom; i &lt; lb.ito; ++i) {
            x[offset++] = fn(this.array[i]);
        }
    }
    MathWorkers.MathWorker.gatherVector(x, this.length, lb.ifrom, tag, rebroadcast);
};

/**
 * Compute the dot product of this Vector with another Vector in parallel.
 *
 * @param {!MathWorkers.Vector} w the other Vector to be dotted with this Vector
 * @param {!string} tag message tag
 * @param {boolean} [rebroadcast] If true, the coordinator broadcasts the result back to the workers.
 * @memberof MathWorkers.Vector
 */
MathWorkers.Vector.prototype.workerDotVector = function(w, tag, rebroadcast) {
    MathWorkers.util.checkVectors(this, w);
    MathWorkers.util.checkNullOrUndefined(tag);
    var lb = MathWorkers.util.loadBalance(this.length);
    var i;
    var tot = 0.0;
    if (global.unrollLoops) {
        var ni3 = lb.ito - 3;
        for (i = lb.ifrom; i &lt; ni3; i += 4) {
            tot += this.array[i] * w.array[i]
                + this.array[i+1] * w.array[i+1]
                + this.array[i+2] * w.array[i+2]
                + this.array[i+3] * w.array[i+3];
        }
        for (; i &lt; lb.ito; ++i) {
            tot += this.array[i] * w.array[i];
        }
    } else {
        for (i = lb.ifrom; i &lt; lb.ito; ++i) {
            tot += this.array[i] * w.array[i];
        }
    }
    MathWorkers.MathWorker.reduceVectorSum(tot, tag, rebroadcast);
};

/**
 * Compute the vector-matrix product of this Vector with a Matrix in parallel.
 * It is assumed that this Vector is transposed such that it is a row vector.
 * The ordering is such that this Vector v A and the Matrix is A: v.A
 *
 * @param {!MathWorkers.Matrix} A the matrix to multiply with
 * @param {!string} tag message tag
 * @param {boolean} [rebroadcast] If true, the coordinator broadcasts the result back to the workers.
 * @memberof MathWorkers.Vector
 */
MathWorkers.Vector.prototype.workerDotMatrix = function(A, tag, rebroadcast) {
    MathWorkers.util.checkVectorMatrix(this, A);
    MathWorkers.util.checkNullOrUndefined(tag);
    var i, j;
    var nj = this.length;
    var lb = MathWorkers.util.loadBalance(A.ncols);
    var w = new Float64Array(lb.ito - lb.ifrom);
    var offset = 0;
    if (global.unrollLoops) {
        var nj3 = nj - 3;
        for (i = lb.ifrom; i &lt; lb.ito; ++i) {
            tot = 0.0;
            for (j = 0; j &lt; nj3; j += 4) {
                tot += this.array[j] * A.array[j][i]
                    + this.array[j+1] * A.array[j+1][i]
                    + this.array[j+2] * A.array[j+2][i]
                    + this.array[j+3] * A.array[j+3][i];
            }
            for (; j &lt; nj; ++j) {
                tot += this.array[j] * A.array[j][i];
            }
            w[offset++] = tot;
        }
    } else {
        for (i = lb.ifrom; i &lt; lb.ito; ++i) {
            var tot = 0.0;
            for (j = 0; j &lt; nj; ++j) {
                tot += this.array[j] * A.array[j][i];
            }
            w[offset++] = tot;
        }
    }
    MathWorkers.MathWorker.gatherVector(w, this.length, lb.ifrom, tag, rebroadcast);
};

// Copyright 2014 Adrian W. Lange

/**
 * Matrix class.
 * A wrapper around an array of Float64Arrays (Array.&lt;Float64Array>) with several matrix operations defined,
 * including worker parallelized operations.
 *
 * @param {number} [nrows] the number of rows in the matrix. If not provided or less than 1, a Matrix
 *                         object is still created but with a null array.
 * @param {number} [ncols] the number of columns in the matrix. If not provided or less than 1, a Matrix
 *                         object is still created but with a null array.
 * @constructor
 * @memberof MathWorkers
 */
MathWorkers.Matrix = function(nrows, ncols) {

    /**
     * &lt;p>The underlying Array.&amp;lt;Float64Array&amp;gt; for a Matrix&lt;/p>
     *
     * @member {Array.&lt;Float64Array>}
     */
    this.array = [];

    /**
     * The number of rows in this Matrix
     *
     * @member {number}
     */
    this.nrows = nrows || 0;

    /**
     * The number of columns in this Matrix
     *
     * @member {number}
     */
    this.ncols = ncols || 0;

    if (nrows > 0 &amp;&amp; ncols > 0) {
        this.array = new Array(nrows);
        for (var r = 0; r &lt; nrows; ++r) {
            this.array[r] = new Float64Array(ncols);
        }
    }
};

/**
 * Create a new Matrix object from a provided 2-dimensional array. Deep copies the array.
 *
 * @param {!Array.&lt;Array.&lt;number>> | !Array.&lt;Float64Array>} arr the 2-dimensional array to be copied
 * @returns {MathWorkers.Matrix} the new Matrix object
 * @memberof MathWorkers.Matrix
 */
MathWorkers.Matrix.fromArray = function(arr) {
    MathWorkers.util.checkArray(arr);
    var mat = new MathWorkers.Matrix(arr.length, arr[0].length);
    var i, j, nj;
    var ni = arr.length;
    for (i = 0; i &lt; ni; ++i) {
        nj = arr[i].length;
        for (j = 0; j &lt; nj; ++j) {
            mat.array[i][j] = arr[i][j];
        }
    }
    return mat;
};

/**
 * Assign the underlying Array.&lt;Float64Array> for this Matrix
 *
 * @param {!Array.&lt;Float64Array>} arr the Array.&lt;Float64Array> to be assigned to this Matrix object
 * @memberof MathWorkers.Matrix
 */
MathWorkers.Matrix.prototype.setMatrix = function(arr) {
    MathWorkers.util.checkArray(arr);
    MathWorkers.util.checkFloat64Array(arr[0]);
    this.array = arr;
    this.nrows = arr.length;
    this.ncols = arr[0].length;
};

/**
 * Copy a provided array into the j-th column of this Matrix
 *
 * @param {!number} j the index of the column to which to copy
 * @param {!Array.&lt;number> | !Float64Array} vec the vector to be copied
 * @memberod MathWorkers.Matrix
 * @ignore
 */
MathWorkers.Matrix.prototype.copyColumn = function(j, vec) {
    for (var i = 0, ni = this.nrows; i &lt; ni; ++i) {
        vec[i] = this.array[i][j];
    }
};

/**
 * Copy a provided array into the i-th row of this Matrix
 *
 * @param {!number} i the index of the row to which to copy
 * @param {!Array.&lt;number> | !Float64Array} vec the vector to be copied
 * @memberof MathWorkers.Matrix
 * @ignore
 */
MathWorkers.Matrix.prototype.copyRow = function(i, vec) {
    for (var j = 0, nj = this.ncols; j &lt; nj; ++j) {
        vec[j] = this.array[i][j];
    }
};

/**
 * Test if this matrix is a square matrix.
 *
 * @returns {boolean} true if this matrix has an equal number row and columns. False otherwise.
 * @memberof MathWorkers.Matrix
 */
MathWorkers.Matrix.prototype.isSquare = function() {
    return this.nrows === this.ncols;
};

/**
 * Create a new Matrix object populated with all zero values.
 *
 * @param {!number} nrows the number of rows for the new Matrix
 * @param {!number} ncols the number of columns for the new Matrix
 * @returns {MathWorkers.Matrix} an nrows by ncols Matrix populated with zeroes
 * @memberof MathWorkers.Matrix
 */
MathWorkers.Matrix.zeroes = function(nrows, ncols) {
    var mat = new MathWorkers.Matrix(nrows, ncols);
    for (var i = 0; i &lt; nrows; ++i) {
        for (var j = 0; j &lt; ncols; ++j) {
            mat.array[i][j] = 0.0;
        }
    }
    return mat;
};

/**
 * Create a new Matrix object whose elements are those of an identity matrix.
 *
 * @param {!number} n the number of rows and columns for the identity matrix
 * @returns {MathWorkers.Matrix} the new identity Matrix object
 * @memberof MathWorkers.Matrix
 */
MathWorkers.Matrix.identity = function(n) {
    var mat = new MathWorkers.Matrix(n, n);
    for (var i = 0; i &lt; n; ++i) {
        for (var j = 0; j &lt; n; ++j) {
            mat.array[i][j] = 0.0;
        }
        mat.array[i][i] = 1.0;
    }
    return mat;
};

/**
 * Create a new Matrix object populated with random values between 0 and 1.
 *
 * @param {!number} nrows the number of rows for the new Matrix
 * @param {!number} ncols the number of columns for the new Matrix
 * @returns {MathWorkers.Matrix} an nrows by ncols Matrix populated with zeroes
 * @memberof MathWorkers.Matrix
 */
MathWorkers.Matrix.randomMatrix = function(nrows, ncols) {
    var mat = new MathWorkers.Matrix(nrows, ncols);
    for (var i = 0; i &lt; nrows; ++i) {
        for (var j = 0; j &lt; ncols; ++j) {
            mat.array[i][j] = Math.random();
        }
    }
    return mat;
};

/**
 * Convert the Matrix data into a printable string
 *
 * @returns {string} the string representation of the Matrix
 * @memberof MathWorkers.Matrix
 */
MathWorkers.Matrix.prototype.toString = function() {
    var str = "";
    for (var i = 0; i &lt; this.nrows; ++i) {
        var row = "[";
        for (var j = 0; j &lt; this.ncols - 1; ++j) {
            row += this.array[i][j] + ", ";
        }
        str += row + this.array[i][this.ncols-1] + "]";
        if (i != this.nrows - 1) {
            str += "\n";
        }
    }
    return str;
};

/**
 * Add this Matrix to another (element-wise).
 *
 * @param {!MathWorkers.Matrix} B the Matrix to add to this Matrix
 * @returns {MathWorkers.Matrix} the element-wise sum of the Matrix and B
 * @memberof MathWorkers.Matrix
 */
MathWorkers.Matrix.prototype.plus = function(B) {
    MathWorkers.util.checkMatrices(this, B);
    var C = new MathWorkers.Matrix(this.nrows, this.ncols);
    var i, j, ai, bi;
    var ni = this.nrows;
    var nj = this.ncols;
    if (global.unrollLoops) {
        var nj3 = nj - 3;
        for (i = 0; i &lt; ni; ++i) {
            ai = this.array[i];
            bi = B.array[i];
            for (j = 0; j &lt; nj3; j += 4) {
                C.array[i][j] = ai[j] + bi[j];
                C.array[i][j+1] = ai[j+1] + bi[j+1];
                C.array[i][j+2] = ai[j+2] + bi[j+2];
                C.array[i][j+3] = ai[j+3] + bi[j+3];
            }
            for (; j &lt; nj; ++j) {
                C.array[i][j] = ai[j] + bi[j];
            }
        }
    } else {
        for (i = 0; i &lt; ni; ++i) {
            ai = this.array[i];
            bi = B.array[i];
            for (j = 0; j &lt; nj; ++j) {
                C.array[i][j] = ai[j] + bi[j];
            }
        }
    }
    return C;
};

/**
 * Subtract another Matrix from this Matrix (element-wise).
 *
 * @param {!MathWorkers.Matrix} B the Matrix to subtract from this Matrix
 * @returns {MathWorkers.Matrix} the element-wise difference of B from this Matrix
 * @memberof MathWorkers.Matrix
 */
MathWorkers.Matrix.prototype.minus = function(B) {
    MathWorkers.util.checkMatrices(this, B);
    var C = new MathWorkers.Matrix(this.nrows, this.ncols);
    var i, j, ai, bi;
    var ni = this.nrows;
    var nj = this.ncols;
    if (global.unrollLoops) {
        var nj3 = nj - 3;
        for (i = 0; i &lt; ni; ++i) {
            ai = this.array[i];
            bi = B.array[i];
            for (j = 0; j &lt; nj3; j += 4) {
                C.array[i][j] = ai[j] - bi[j];
                C.array[i][j+1] = ai[j+1] - bi[j+1];
                C.array[i][j+2] = ai[j+2] - bi[j+2];
                C.array[i][j+3] = ai[j+3] - bi[j+3];
            }
            for (; j &lt; nj; ++j) {
                C.array[i][j] = ai[j] - bi[j];
            }
        }
    } else {
        for (i = 0; i &lt; ni; ++i) {
            ai = this.array[i];
            bi = B.array[i];
            for (j = 0; j &lt; nj; ++j) {
                C.array[i][j] = ai[j] - bi[j];
            }
        }
    }
    return C;
};

/**
 * Multiply this Matrix with another (element-wise).
 *
 * @param {!MathWorkers.Matrix} B the Matrix to multiply with this Matrix
 * @returns {MathWorkers.Matrix} the element-wise product of this Matrix and B
 * @memberof MathWorkers.Matrix
 */
MathWorkers.Matrix.prototype.times = function(B) {
    MathWorkers.util.checkMatrices(this, B);
    var C = new MathWorkers.Matrix(this.nrows, this.ncols);
    var i, j, ai, bi;
    var ni = this.nrows;
    var nj = this.ncols;
    if (global.unrollLoops) {
        var nj3 = nj - 3;
        for (i = 0; i &lt; ni; ++i) {
            ai = this.array[i];
            bi = B.array[i];
            for (j = 0; j &lt; nj3; j += 4) {
                C.array[i][j] = ai[j] * bi[j];
                C.array[i][j+1] = ai[j+1] * bi[j+1];
                C.array[i][j+2] = ai[j+2] * bi[j+2];
                C.array[i][j+3] = ai[j+3] * bi[j+3];
            }
            for (; j &lt; nj; ++j) {
                C.array[i][j] = ai[j] * bi[j];
            }
        }
    } else {
        for (i = 0; i &lt; ni; ++i) {
            ai = this.array[i];
            bi = B.array[i];
            for (j = 0; j &lt; nj; ++j) {
                C.array[i][j] = ai[j] * bi[j];
            }
        }
    }
    return C;
};

/**
 * Divide this Matrix by another (element-wise).
 *
 * @param {!MathWorkers.Matrix} B the Matrix to divide this Matrix by
 * @returns {MathWorkers.Matrix} the element-wise quotient of this Matrix by B
 * @memberof MathWorkers.Matrix
 */
MathWorkers.Matrix.prototype.divide = function(B) {
    MathWorkers.util.checkMatrices(this, B);
    var C = new MathWorkers.Matrix(this.nrows, this.ncols);
    var i, j, ai, bi;
    var ni = this.nrows;
    var nj = this.ncols;
    if (global.unrollLoops) {
        var nj3 = nj - 3;
        for (i = 0; i &lt; ni; ++i) {
            ai = this.array[i];
            bi = B.array[i];
            for (j = 0; j &lt; nj3; j += 4) {
                C.array[i][j] = ai[j] / bi[j];
                C.array[i][j+1] = ai[j+1] / bi[j+1];
                C.array[i][j+2] = ai[j+2] / bi[j+2];
                C.array[i][j+3] = ai[j+3] / bi[j+3];
            }
            for (; j &lt; nj; ++j) {
                C.array[i][j] = ai[j] / bi[j];
            }
        }
    } else {
        for (i = 0; i &lt; ni; ++i) {
            ai = this.array[i];
            bi = B.array[i];
            for (j = 0; j &lt; nj; ++j) {
                C.array[i][j] = ai[j] / bi[j];
            }
        }
    }
    return C;
};

/**
 * Multiply all elements of this Matrix by a scalar.
 *
 * @param {!number} alpha the scalar to multiply by
 * @returns {MathWorkers.Matrix} the scaled Matrix
 * @memberof MathWorkers.Matrix
 */
MathWorkers.Matrix.prototype.scale = function(alpha) {
    MathWorkers.util.checkNumber(alpha);
    var C = new MathWorkers.Matrix(this.nrows, this.ncols);
    var i, j, ai;
    var ni = this.nrows;
    var nj = this.ncols;
    if (global.unrollLoops) {
        var nj3 = nj - 3;
        for (i = 0; i &lt; ni; ++i) {
            ai = this.array[i];
            for (j = 0; j &lt; nj3; j += 4) {
                C.array[i][j] = ai[j] * alpha;
                C.array[i][j+1] = ai[j+1] * alpha;
                C.array[i][j+2] = ai[j+2] * alpha;
                C.array[i][j+3] = ai[j+3] * alpha;
            }
            for (; j &lt; nj; ++j) {
                C.array[i][j] = ai[j] * alpha;
            }
        }
    } else {
        for (i = 0; i &lt; ni; ++i) {
            ai = this.array[i];
            for (j = 0; j &lt; nj; ++j) {
                C.array[i][j] = ai[j] * alpha;
            }
        }
    }
    return C;
};

/**
 * Apply (or, map) a function onto each value in this Matrix. The function must take a number as its argument and
 * return a number. That is, the function must map a number to a number.
 *
 * @param {!function} fn the function to be applied to each element of the Matrix
 * @returns {MathWorkers.Matrix} the mapped Matrix
 * @memberof MathWorkers.Matrix
 */
MathWorkers.Matrix.prototype.apply = function(fn) {
    MathWorkers.util.checkFunction(fn);
    var C = new MathWorkers.Matrix(this.nrows, this.ncols);
    var i, j, ai;
    var ni = this.nrows;
    var nj = this.ncols;
    if (global.unrollLoops) {
        var nj3 = nj - 3;
        for (i = 0; i &lt; ni; ++i) {
            ai = this.array[i];
            for (j = 0; j &lt; nj3; j += 4) {
                C.array[i][j] = fn(ai[j]);
                C.array[i][j+1] = fn(ai[j+1]);
                C.array[i][j+2] = fn(ai[j+2]);
                C.array[i][j+3] = fn(ai[j+3]);
            }
            for (; j &lt; nj; ++j) {
                C.array[i][j] = fn(ai[j]);
            }
        }
    } else {
        for (i = 0; i &lt; ni; ++i) {
            ai = this.array[i];
            for (j = 0; j &lt; nj; ++j) {
                C.array[i][j] = fn(ai[j]);
            }
        }
    }
    return C;
};

/**
 * Transpose this Matrix. Returns a new Matrix to allow for arbitrary shaped matrices.
 *
 * @returns {MathWorkers.Matrix} a new Matrix that is the transpose of this Matrix
 * @memberof MathWorkers.Matrix
 */
MathWorkers.Matrix.prototype.transpose = function() {
    var B = new MathWorkers.Matrix(this.ncols, this.nrows);
    var i, j, ai;
    var ni = this.nrows;
    var nj = this.ncols;
    for (i = 0; i &lt; ni; ++i) {
        ai = this.array[i];
        for (j = 0; j &lt; nj; ++j) {
            B.array[j][i] = ai[j];
        }
    }
    return B;
};

/**
 * Transpose this square matrix in place. Only works for square matrices.
 *
 * @returns {MathWorkers.Matrix} this Matrix transposed
 * @throws {Error} thrown if this Matrix is not a square matrix.
 * @memberof MathWorkers.Matrix
 */
MathWorkers.Matrix.prototype.transposeInPlace = function() {
    if (this.isSquare()) {
        var i, j;
        var ni = this.nrows;
        var nj = this.ncols;
        for (i = 0; i &lt; ni; ++i) {
            for (j = i + 1; j &lt; nj; ++j) {
                var tmp = this.array[i][j];
                this.array[i][j] = this.array[j][i];
                this.array[j][i] = tmp;
            }
        }
    } else {
        throw new Error("In place transpose only available for square matrices.");
    }
    return this;
};

/**
 * Compute the matrix-vector product of this Matrix with a Vector.
 * It is assumed that this Vector is transposed such that it is a column vector.
 * The ordering is such that this Matrix is A and the Vector is v: A.v
 *
 * @param {!MathWorkers.Vector} v the Vector to be multiplied with
 * @returns {MathWorkers.Vector} the resulting Vector of the Matrix-Vector product
 * @memberof MathWorkers.Matrix
 */
MathWorkers.Matrix.prototype.dotVector = function(v) {
    MathWorkers.util.checkMatrixVector(this, v);
    var w = new MathWorkers.Vector(this.nrows);
    var tot;
    var i, j;
    var ni = this.nrows;
    var nj = this.ncols;
    var ai;
    if (global.unrollLoops) {
        var nj3 = nj - 3;
        for (i = 0; i &lt; ni; ++i) {
            tot = 0.0;
            ai = this.array[i];
            for (j = 0; j &lt; nj3; j += 4) {
                tot += ai[j] * v.array[j]
                    + ai[j+1] * v.array[j+1]
                    + ai[j+2] * v.array[j+2]
                    + ai[j+3] * v.array[j+3];
            }
            for (; j &lt; nj; ++j) {
                tot += ai[j] * v.array[j];
            }
            w.array[i] = tot;
        }
    } else {
        for (i = 0; i &lt; ni; ++i) {
            tot = 0.0;
            ai = this.array[i];
            for (j = 0; j &lt; nj; ++j) {
                tot += ai[j] * v.array[j];
            }
            w.array[i] = tot;
        }
    }
    return w;
};

/**
 * Compute the matrix-matrix product of this Matrix with another Matrix. The ordering
 * is such that this Matrix is A and the other matrix is B: A.B
 *
 * @param {!MathWorkers.Matrix} B the Matrix to multiply with this Matrix
 * @returns {MathWorkers.Matrix} the resulting Matrix of the matrix-matrix product
 * @memberof MathWorkers.Matrix
 */
MathWorkers.Matrix.prototype.dotMatrix = function(B) {
    MathWorkers.util.checkMatrixMatrix(this, B);
    var C = new MathWorkers.Matrix(this.nrows, B.ncols);

    var i, j, k, tot, ai;
    var ni = this.nrows;
    var nj = this.ncols;
    var nk = B.ncols;

    var Bk = new Float64Array(nj);
    if (global.unrollLoops) {
        var nj3 = nj - 3;
        for (k = 0; k &lt; nk; ++k) {
            B.copyColumn(k, Bk);
            for (i = 0; i &lt; ni; ++i) {
                tot = 0.0;
                ai = this.array[i];
                for (j = 0; j &lt; nj3; j += 4) {
                    tot += ai[j] * Bk[j]
                        + ai[j+1] * Bk[j+1]
                        + ai[j+2] * Bk[j+2]
                        + ai[j+3] * Bk[j+3];
                }
                for (; j &lt; nj; ++j) {
                    tot += ai[j] * Bk[j];
                }
                C.array[i][k] = tot;
            }
        }
    } else {
        for (k = 0; k &lt; nk; ++k) {
            B.copyColumn(k, Bk);
            for (i = 0; i &lt; ni; ++i) {
                tot = 0.0;
                ai = this.array[i];
                for (j = 0; j &lt; nj; ++j) {
                    tot += ai[j] * Bk[j];
                }
                C.array[i][k] = tot;
            }
        }
    }
    return C;
};

// Copyright 2014 Adrian W. Lange

/*
 * Parallel worker versions of the Matrix methods
 */

/**
 * Add this Matrix to another (element-wise) in parallel.
 *
 * @param {!MathWorkers.Matrix} B the Matrix to add to this Matrix
 * @param {!string} tag message tag
 * @param {boolean} [rebroadcast] If true, the coordinator broadcasts the result back to the workers.
 * @memberof MathWorkers.Matrix
 */
MathWorkers.Matrix.prototype.workerPlus = function(B, tag, rebroadcast) {
    MathWorkers.util.checkMatrices(this, B);
    MathWorkers.util.checkNullOrUndefined(tag);
    var lb = MathWorkers.util.loadBalance(this.nrows);
    var C = [];
    var offset = 0;
    var i, j, ai, bi, co;
    var nj = this.ncols;
    if (global.unrollLoops) {
        var nj3 = nj - 3;
        for (i = lb.ifrom; i &lt; lb.ito; ++i) {
            C.push(new Float64Array(nj));
            ai = this.array[i];
            bi = B.array[i];
            co = C[offset];
            for (j = 0; j &lt; nj3; j += 4) {
                co[j] = ai[j] + bi[j];
                co[j+1] = ai[j+1] + bi[j+1];
                co[j+2] = ai[j+2] + bi[j+2];
                co[j+3] = ai[j+3] + bi[j+3];
            }
            for (; j &lt; nj; ++j) {
                co[j] = ai[j] + bi[j];
            }
            ++offset;
        }
    } else {
        for (i = lb.ifrom; i &lt; lb.ito; ++i) {
            C.push(new Float64Array(nj));
            ai = this.array[i];
            bi = B.array[i];
            co = C[offset];
            for (j = 0; j &lt; nj; ++j) {
                co[j] = ai[j] + bi[j];
            }
            ++offset;
        }
    }
    MathWorkers.MathWorker.gatherMatrixRows(C, this.nrows, lb.ifrom, tag, rebroadcast);
};

/**
 * Subtract another Matrix from this Matrix (element-wise) in parallel.
 *
 * @param {!MathWorkers.Matrix} B the Matrix to subtract from this Matrix
 * @param {!string} tag message tag
 * @param {boolean} [rebroadcast] If true, the coordinator broadcasts the result back to the workers.
 * @memberof MathWorkers.Matrix
 */
MathWorkers.Matrix.prototype.workerMinus = function(B, tag, rebroadcast) {
    MathWorkers.util.checkMatrices(this, B);
    MathWorkers.util.checkNullOrUndefined(tag);
    var lb = MathWorkers.util.loadBalance(this.nrows);
    var C = [];
    var offset = 0;
    var i, j, ai, bi, co;
    var nj = this.ncols;
    if (global.unrollLoops) {
        var nj3 = nj - 3;
        for (i = lb.ifrom; i &lt; lb.ito; ++i) {
            C.push(new Float64Array(nj));
            ai = this.array[i];
            bi = B.array[i];
            co = C[offset];
            for (j = 0; j &lt; nj3; j += 4) {
                co[j] = ai[j] - bi[j];
                co[j+1] = ai[j+1] - bi[j+1];
                co[j+2] = ai[j+2] - bi[j+2];
                co[j+3] = ai[j+3] - bi[j+3];
            }
            for (; j &lt; nj; ++j) {
                co[j] = ai[j] - bi[j];
            }
            ++offset;
        }
    } else {
        for (i = lb.ifrom; i &lt; lb.ito; ++i) {
            C.push(new Float64Array(nj));
            ai = this.array[i];
            bi = B.array[i];
            co = C[offset];
            for (j = 0; j &lt; nj; ++j) {
                co[j] = ai[j] - bi[j];
            }
            ++offset;
        }
    }
    MathWorkers.MathWorker.gatherMatrixRows(C, this.nrows, lb.ifrom, tag, rebroadcast);
};

/**
 * Multiply this Matrix with another (element-wise) in parallel.
 *
 * @param {!MathWorkers.Matrix} B the Matrix to multiply with this Matrix
 * @param {!string} tag message tag
 * @param {boolean} [rebroadcast] If true, the coordinator broadcasts the result back to the workers.
 * @memberof MathWorkers.Matrix
 */
MathWorkers.Matrix.prototype.workerTimes = function(B, tag, rebroadcast) {
    MathWorkers.util.checkMatrices(this, B);
    MathWorkers.util.checkNullOrUndefined(tag);
    var lb = MathWorkers.util.loadBalance(this.nrows);
    var C = [];
    var offset = 0;
    var i, j, ai, bi, co;
    var nj = this.ncols;
    if (global.unrollLoops) {
        var nj3 = nj - 3;
        for (i = lb.ifrom; i &lt; lb.ito; ++i) {
            C.push(new Float64Array(nj));
            ai = this.array[i];
            bi = B.array[i];
            co = C[offset];
            for (j = 0; j &lt; nj3; j += 4) {
                co[j] = ai[j] * bi[j];
                co[j+1] = ai[j+1] * bi[j+1];
                co[j+2] = ai[j+2] * bi[j+2];
                co[j+3] = ai[j+3] * bi[j+3];
            }
            for (; j &lt; nj; ++j) {
                co[j] = ai[j] * bi[j];
            }
            ++offset;
        }
    } else {
        for (i = lb.ifrom; i &lt; lb.ito; ++i) {
            C.push(new Float64Array(nj));
            ai = this.array[i];
            bi = B.array[i];
            co = C[offset];
            for (j = 0; j &lt; nj; ++j) {
                co[j] = ai[j] * bi[j];
            }
            ++offset;
        }
    }
    MathWorkers.MathWorker.gatherMatrixRows(C, this.nrows, lb.ifrom, tag, rebroadcast);
};

/**
 * Divide this Matrix by another (element-wise) in parallel.
 *
 * @param {!MathWorkers.Matrix} B the Matrix to divide this Matrix by
 * @param {!string} tag message tag
 * @param {boolean} [rebroadcast] If true, the coordinator broadcasts the result back to the workers.
 * @memberof MathWorkers.Matrix
 */
MathWorkers.Matrix.prototype.workerDivide = function(B, tag, rebroadcast) {
    MathWorkers.util.checkMatrices(this, B);
    MathWorkers.util.checkNullOrUndefined(tag);
    var lb = MathWorkers.util.loadBalance(this.nrows);
    var C = [];
    var offset = 0;
    var i, j, ai, bi, co;
    var nj = this.ncols;
    if (global.unrollLoops) {
        var nj3 = nj - 3;
        for (i = lb.ifrom; i &lt; lb.ito; ++i) {
            C.push(new Float64Array(nj));
            ai = this.array[i];
            bi = B.array[i];
            co = C[offset];
            for (j = 0; j &lt; nj3; j += 4) {
                co[j] = ai[j] / bi[j];
                co[j+1] = ai[j+1] / bi[j+1];
                co[j+2] = ai[j+2] / bi[j+2];
                co[j+3] = ai[j+3] / bi[j+3];
            }
            for (; j &lt; nj; ++j) {
                co[j] = ai[j] / bi[j];
            }
            ++offset;
        }
    } else {
        for (i = lb.ifrom; i &lt; lb.ito; ++i) {
            C.push(new Float64Array(nj));
            ai = this.array[i];
            bi = B.array[i];
            co = C[offset];
            for (j = 0; j &lt; nj; ++j) {
                co[j] = ai[j] / bi[j];
            }
            ++offset;
        }
    }
    MathWorkers.MathWorker.gatherMatrixRows(C, this.nrows, lb.ifrom, tag, rebroadcast);
};

/**
 * Multiply all elements of this Matrix by a scalar in parallel.
 *
 * @param {!number} alpha the scalar to multiply by
 * @param {!string} tag message tag
 * @param {boolean} [rebroadcast] If true, the coordinator broadcasts the result back to the workers.
 * @memberof MathWorkers.Matrix
 */
MathWorkers.Matrix.prototype.workerScale = function(alpha, tag, rebroadcast) {
    MathWorkers.util.checkNumber(alpha);
    MathWorkers.util.checkNullOrUndefined(tag);
    var lb = MathWorkers.util.loadBalance(this.nrows);
    var C = [];
    var offset = 0;
    var i, j, ai, co;
    var nj = this.ncols;
    if (global.unrollLoops) {
        var nj3 = nj - 3;
        for (i = lb.ifrom; i &lt; lb.ito; ++i) {
            C.push(new Float64Array(nj));
            ai = this.array[i];
            co = C[offset];
            for (j = 0; j &lt; nj3; j += 4) {
                co[j] = ai[j] * alpha;
                co[j+1] = ai[j+1] * alpha;
                co[j+2] = ai[j+2] * alpha;
                co[j+3] = ai[j+3] * alpha;
            }
            for (; j &lt; nj; ++j) {
                co[j] = ai[j] * alpha;
            }
            ++offset;
        }
    } else {
        for (i = lb.ifrom; i &lt; lb.ito; ++i) {
            C.push(new Float64Array(nj));
            ai = this.array[i];
            co = C[offset];
            for (j = 0; j &lt; nj; ++j) {
                co[j] = ai[j] * alpha;
            }
            ++offset;
        }
    }
    MathWorkers.MathWorker.gatherMatrixRows(C, this.nrows, lb.ifrom, tag, rebroadcast);
};

/**
 * Apply (or, map) a function onto each value in this Matrix in parallel. The function must take a number as its
 * argument and return a number. That is, the function must map a number to a number.
 *
 * @param {!function} fn the function to be applied to each element of this Matrix
 * @param {!string} tag message tag
 * @param {boolean} [rebroadcast] If true, the coordinator broadcasts the result back to the workers.
 * @memberof MathWorkers.Matrix
 */
MathWorkers.Matrix.prototype.workerApply = function(fn, tag, rebroadcast) {
    MathWorkers.util.checkFunction(fn);
    MathWorkers.util.checkNullOrUndefined(tag);
    var lb = MathWorkers.util.loadBalance(this.nrows);
    var C = [];
    var offset = 0;
    var i, j, ai, co;
    var nj = this.ncols;
    if (global.unrollLoops) {
        var nj3 = nj - 3;
        for (i = lb.ifrom; i &lt; lb.ito; ++i) {
            C.push(new Float64Array(nj));
            ai = this.array[i];
            co = C[offset];
            for (j = 0; j &lt; nj3; j += 4) {
                co[j] = fn(ai[j]);
                co[j+1] = fn(ai[j+1]);
                co[j+2] = fn(ai[j+2]);
                co[j+3] = fn(ai[j+3]);
            }
            for (; j &lt; nj; ++j) {
                co[j] = fn(ai[j]);
            }
            ++offset;
        }
    } else {
        for (i = lb.ifrom; i &lt; lb.ito; ++i) {
            C.push(new Float64Array(nj));
            ai = this.array[i];
            co = C[offset];
            for (j = 0; j &lt; nj; ++j) {
                co[j] = fn(ai[j]);
            }
            ++offset;
        }
    }
    MathWorkers.MathWorker.gatherMatrixRows(C, this.nrows, lb.ifrom, tag, rebroadcast);
};

/**
 * Compute the matrix-vector product of this Matrix with a Vector in parallel.
 * It is assumed that this Vector is transposed such that it is a column vector.
 * The ordering is such that this Matrix is A and the Vector is v: A.v
 *
 * @param {!MathWorkers.Vector} v the Vector to be multiplied with
 * @param {!string} tag message tag
 * @param {boolean} [rebroadcast] If true, the coordinator broadcasts the result back to the workers.
 * @memberof MathWorkers.Matrix
 */
MathWorkers.Matrix.prototype.workerDotVector = function(v, tag, rebroadcast) {
    MathWorkers.util.checkMatrixVector(this, v);
    MathWorkers.util.checkNullOrUndefined(tag);
    var lb = MathWorkers.util.loadBalance(this.nrows);
    var w = new Float64Array(lb.ito - lb.ifrom);
    var i, j, tot, ai;
    var nj = this.ncols;
    var offset = 0;
    if (global.unrollLoops) {
        var nj3 = nj - 3;
        for (i = lb.ifrom; i &lt; lb.ito; ++i) {
            ai = this.array[i];
            tot = 0.0;
            for (j = 0; j &lt; nj3; j += 4) {
                tot += ai[j] * v.array[j]
                    + ai[j+1] * v.array[j+1]
                    + ai[j+2] * v.array[j+2]
                    + ai[j+3] * v.array[j+3];
            }
            for (; j &lt; nj; ++j) {
                tot += ai[j] * v.array[j];
            }
            w[offset++] = tot;
        }
    } else {
        for (i = lb.ifrom; i &lt; lb.ito; ++i) {
            ai = this.array[i];
            tot = 0.0;
            for (j = 0; j &lt; nj; ++j) {
                tot += ai[j] * v.array[j];
            }
            w[offset++] = tot;
        }
    }
    MathWorkers.MathWorker.gatherVector(w, v.length, lb.ifrom, tag, rebroadcast);
};

/**
 * Compute the matrix-matrix product of this Matrix with another Matrix in parallel. The ordering
 * is such that this Matrix is A and the other matrix is B: A.B
 *
 * @param {!MathWorkers.Matrix} B the Matrix to multiply with this Matrix
 * @param {!string} tag message tag
 * @param {boolean} [rebroadcast] If true, the coordinator broadcasts the result back to the workers.
 * @memberof MathWorkers.Matrix
 */
MathWorkers.Matrix.prototype.workerDotMatrix = function(B, tag, rebroadcast) {
    MathWorkers.util.checkMatrixMatrix(this, B);
    MathWorkers.util.checkNullOrUndefined(tag);

    var i, j, k, tot, ai;
    var ni = this.nrows;
    var nj = this.ncols;
    var lb = MathWorkers.util.loadBalance(B.ncols);
    var nk = lb.ito - lb.ifrom;

    // transposed
    var C = new Array(nk);
    for (k = 0; k &lt; nk; ++k) {
        C[k] = new Float64Array(ni);
    }

    var Bk = new Float64Array(nj);
    if (global.unrollLoops) {
        var nj3 = nj - 3;
        for (k = 0; k &lt; nk; ++k) {
            B.copyColumn(lb.ifrom + k, Bk);
            for (i = 0; i &lt; ni; ++i) {
                tot = 0.0;
                ai = this.array[i];
                for (j = 0; j &lt; nj3; j += 4) {
                    tot += ai[j] * Bk[j]
                        + ai[j+1] * Bk[j+1]
                        + ai[j+2] * Bk[j+2]
                        + ai[j+3] * Bk[j+3];
                }
                for (; j &lt; nj; ++j) {
                    tot += ai[j] * Bk[j];
                }
                C[k][i] = tot;
            }
        }
    } else {
        for (k = 0; k &lt; nk; ++k) {
            B.copyColumn(lb.ifrom + k, Bk);
            for (i = 0; i &lt; ni; ++i) {
                tot = 0.0;
                ai = this.array[i];
                for (j = 0; j &lt; nj; ++j) {
                    tot += ai[j] * Bk[j];
                }
                C[k][i] = tot;
            }
        }
    }

    MathWorkers.MathWorker.gatherMatrixColumns(C, this.nrows, B.ncols, lb.ifrom, tag, rebroadcast);
};

// Copyright 2014 Adrian W. Lange

// TODO: Finish unrolling these guys

/**
 * Batch operation methods.
 *
 * Combine multiple primitive Vector and/or Matrix operations into a single
 * method call, reducing some overhead, especially with regard to communication.
 *
 * @namespace MathWorkers.Batch
 */
MathWorkers.Batch = {};

/**
 * &lt;p>Compute (in parallel) a linear combination of Vectors, each with a coefficient in a corresponding array:&lt;/p>
 * &lt;p>w = c&lt;sub>0&lt;/sub> * v&lt;sub>0&lt;/sub> + c&lt;sub>1&lt;/sub> * v&lt;sub>1&lt;/sub> + ...&lt;/p>
 *
 * @param {!Array.&lt;MathWorkers.Vector>} vectors the array of Vectors
 * @param {!Array.&lt;number>} coefficients the array of coefficients
 * @param {!string} tag message tag
 * @param {boolean} [rebroadcast] If true, the coordinator broadcasts the result back to the workers.
 * @function workerVectorLinearCombination
 * @memberof MathWorkers.Batch
 */
MathWorkers.Batch.workerVectorLinearCombination = function (vectors, coefficients, tag, rebroadcast) {
    MathWorkers.util.checkNumber(coefficients[0]);
    MathWorkers.util.checkVector(vectors[0]);
    MathWorkers.util.checkNullOrUndefined(tag);

    // First combo initializes x
    var i, a, ni3;
    var offset = 0;
    var vec = vectors[0];
    var coeff = coefficients[0];
    var lb = MathWorkers.util.loadBalance(vec.length);
    var x = new Float64Array(lb.ito - lb.ifrom);
    if (global.unrollLoops) {
        ni3 = lb.ito - 3;
        for (i = lb.ifrom; i &lt; ni3; ++i) {
            x[offset++] = coeff * vec.array[i];
            x[offset++] = coeff * vec.array[i + 1];
            x[offset++] = coeff * vec.array[i + 2];
            x[offset++] = coeff * vec.array[i + 3];
        }
        for (; i &lt; lb.ito; ++i) {
            x[offset++] = coeff * vec.array[i];
        }
    } else {
        for (i = lb.ifrom; i &lt; lb.ito; ++i) {
            x[offset++] = coeff * vec.array[i];
        }
    }

    // Remaining combos
    for (a = 1; a &lt; vectors.length; ++a) {
        offset = 0;
        vec = vectors[a];
        coeff = coefficients[a];
        MathWorkers.util.checkNumber(coeff);
        MathWorkers.util.checkVectors(vectors[a - 1], vec);
        if (global.unrollLoops) {
            for (i = lb.ifrom; i &lt; ni3; ++i) {
                x[offset++] += coeff * vec.array[i];
                x[offset++] += coeff * vec.array[i + 1];
                x[offset++] += coeff * vec.array[i + 2];
                x[offset++] += coeff * vec.array[i + 3];
            }
            for (; i &lt; lb.ito; ++i) {
                x[offset++] += coeff * vec.array[i];
            }
        } else {
            for (i = lb.ifrom; i &lt; lb.ito; ++i) {
                x[offset++] += coeff * vec.array[i];
            }
        }
    }

    MathWorkers.MathWorker.gatherVector(x, vec.length, lb.ifrom, tag, rebroadcast);
};

/**
 * &lt;p>Compute (in parallel) a linear combination of matrices, each with a coefficient in a corresponding array:&lt;/p>
 * &lt;p>B = c&lt;sub>0&lt;/sub> * A&lt;sub>0&lt;/sub> + c&lt;sub>1&lt;/sub> * A&lt;sub>1&lt;/sub> + ...&lt;/p>
 *
 * @param {!Array.&lt;MathWorkers.Matrix>} matrices the array of Matrix objects
 * @param {!Array.&lt;number>} coefficients the array of coefficients
 * @param {!string} tag message tag
 * @param {boolean} [rebroadcast] If true, the coordinator broadcasts the result back to the workers.
 * @function workerMatrixLinearCombination
 * @memberof MathWorkers.Batch
 */
MathWorkers.Batch.workerMatrixLinearCombination = function(matrices, coefficients, tag, rebroadcast) {
    MathWorkers.util.checkNumber(coefficients[0]);
    MathWorkers.util.checkMatrix(matrices[0]);
    MathWorkers.util.checkNullOrUndefined(tag);

    // First combo initializes M
    var M = [];
    var offset = 0;
    var mat = matrices[0];
    var coeff = coefficients[0];
    var lb = MathWorkers.util.loadBalance(matrices[0].nrows);
    for (var i = lb.ifrom; i &lt; lb.ito; ++i) {
        M.push(new Float64Array(mat.ncols));
        for (var j = 0; j &lt; mat.ncols; ++j) {
            M[offset][j] = coeff * mat.array[i][j];
        }
        ++offset;
    }

    // Remaining combos
    for (var a = 1; a &lt; matrices.length; ++a) {
        offset = 0;
        mat = matrices[a];
        coeff = coefficients[a];
        MathWorkers.util.checkNumber(coeff);
        MathWorkers.util.checkMatrices(matrices[a-1], mat);
        for (i = lb.ifrom; i &lt; lb.ito; ++i) {
            for (j = 0; j &lt; mat.ncols; ++j) {
                M[offset][j] += coeff * mat.array[i][j]
            }
            ++offset;
        }
    }

    MathWorkers.MathWorker.gatherMatrixRows(M, mat.nrows, lb.ifrom, tag, rebroadcast);
};

/**
 * &lt;p>Compute (in parallel) a matrix-vector product in combination with adding another vector to its result and also
 * multiplying by scalars. Operation is of the form:&lt;/p>
 * &lt;p> z = alpha * A.x + beta * y&lt;/p>
 * &lt;p>The parameters beta and y are optional, but both must be provided for them to be included.&lt;/p>
 *
 * @param {!number} alpha scalar to multiply the matrix-vector product by
 * @param {!MathWorkers.Matrix} A the Matrix in the matrix-vector product
 * @param {!MathWorkers.Vector} x the Vector in the matrix-vector product
 * @param {!string} tag message tag
 * @param {boolean} [rebroadcast] If true, the coordinator broadcasts the result back to the workers.
 * @param {number} [beta] optional scalar to multiply Vector y by
 * @param {MathWorkers.Vector} [y] optional Vector to be scaled by beta and then added the the matrix-vector product.
 * @function workerMatrixVectorPlus
 * @memberof MathWorkers.Batch
 */
 MathWorkers.Batch.workerMatrixVectorPlus = function(alpha, A, x, tag, rebroadcast, beta, y) {
    MathWorkers.util.checkNumber(alpha);
    MathWorkers.util.checkMatrixVector(A, x);
    MathWorkers.util.checkNullOrUndefined(tag);

    var lb = MathWorkers.util.loadBalance(A.nrows);
    var z = new Float64Array(lb.ito - lb.ifrom);
    var offset = 0;
    if (beta &amp;&amp; y) {
        MathWorkers.util.checkNumber(beta);
        MathWorkers.util.checkVectors(x, y);
        for (var i = lb.ifrom; i &lt; lb.ito; ++i) {
            var tot = 0.0;
            for (var j = 0; j &lt; this.ncols; ++j) {
                tot += A.array[i][j] * v.array[j];
            }
            z[offset++] = alpha * tot + beta * y[i];
        }
    } else {
        for (i = lb.ifrom; i &lt; lb.ito; ++i) {
            tot = 0.0;
            for (j = 0; j &lt; this.ncols; ++j) {
                tot += A.array[i][j] * v.array[j];
            }
            z[offset++] = alpha * tot;
        }
    }
    MathWorkers.MathWorker.gatherVector(z, x.length, lb.ifrom, tag, rebroadcast);
};


/**
 * &lt;p>Compute (in parallel) a matrix-matrix product in combination with adding another matrix to its result and also
 * multiplying by scalars. Operation is of the form:&lt;/p>
 * &lt;p>D = alpha * A.B + beta * C&lt;/p>
 * &lt;p>The parameters beta and C are optional, but both must be provided for them to be included.&lt;/p>
 *
 * @param {!number} alpha the scalar to multiply the matrix-matrix product by
 * @param {!MathWorkers.Matrix} A the left-side Matrix in the matrix-matrix product
 * @param {!MathWorkers.Matrix} B the right-side Matrix in the matrix-matrix product
 * @param {!string} tag message tag
 * @param {boolean} [rebroadcast] If true, the coordinator broadcasts the result back to the workers.
 * @param {number} [beta] the scalar to multiply the Matrix C by
 * @param {MathWorkers.Matrix} [C] the Matrix to be scaled by beta and then added to the matrix-matrix product
 * @function workerMatrixMatrixPlus
 * @memberof MathWorkers.Batch
 */
 MathWorkers.Batch.workerMatrixMatrixPlus = function(alpha, A, B, tag, rebroadcast, beta, C) {
    MathWorkers.util.checkNumber(alpha);
    MathWorkers.util.checkMatrixMatrix(A, B);
    MathWorkers.util.checkNullOrUndefined(tag);

    // Transpose B for better row-major memory access
    // If square, save on memory by doing an in-place transpose
    var Bt = B.isSquare() ? B.transposeInPlace() : B.transpose();
    var lb = MathWorkers.util.loadBalance(A.nrows);
    var D = [];
    var offset = 0;

    if (beta &amp;&amp; C) {
        MathWorkers.util.checkNumber(beta);
        MathWorkers.util.checkMatrix(C);
        if (!(A.nrows === C.nrows &amp;&amp; B.ncols === C.ncols)) {
            throw new Error("Matrix dimensions not compatible for addition.");
        }

        for (var i = lb.ifrom; i &lt; lb.ito; ++i) {
            D.push(new Float64Array(B.ncols));
            for (var j = 0; j &lt; B.ncols; ++j) {
                var tot = 0.0;
                for (var k = 0; k &lt; A.ncols; ++k) {
                    tot += A.array[i][k] * Bt.array[j][k];
                }
                D[offset][j] = alpha * tot + beta * C.array[i][j];
            }
            ++offset;
        }
    } else {
        for (i = lb.ifrom; i &lt; lb.ito; ++i) {
            D.push(new Float64Array(B.ncols));
            for (j = 0; j &lt; B.ncols; ++j) {
                tot = 0.0;
                for (k = 0; k &lt; A.ncols; ++k) {
                    tot += A.array[i][k] * Bt.array[j][k];
                }
                D[offset][j] = alpha * tot;
            }
            ++offset;
        }
    }

    // restore B
    if (B.isSquare) {
        B.transposeInPlace();
    }

    MathWorkers.MathWorker.gatherMatrixRows(D, A.nrows, lb.ifrom, tag, rebroadcast);
};


// Copyright 2014 Adrian W. Lange

/**
 * Statistics methods namespace.
 *
 * @namespace MathWorkers.Stats
 */
MathWorkers.Stats = {};

/**
 * A statistical summary of a sample of numbers
 *
 * @typedef {Object} StatisticsSummary
 * @property {number} n number of elements sampled in this summary
 * @property {number} mean mean of the sample
 * @property {number} variance variance of the sample
 * @property {number} stddev standard deviation of the sample
 * @property {number} minimum minimum value in the sample
 * @property {number} maximum maximum value in the sample
 * @property {?number} quartile25 25th percentile value
 * @property {?number} quartile50 50th percentile value (or, the median)
 * @property {?number} quartile75 75th percentile value
 */

/**
 * Compute basic summary statistics for a generic Array, Float64Array, Vector, or Matrix
 *
 * Returns an object containing number of elements, mean, standard deviation,
 * minimum, maximum, and quartiles. The quartiles computed here are the so-called
 * "Tukey's Hinges".
 *
 * Quartiles are not reported if the data passed in contains less than 3 elements
 *
 * @param data {Array.&lt;number>|Float64Array|MathWorkers.Vector|MathWorkers.Matrix} sample of numbers to be summarized
 * @returns {StatisticsSummary}
 * @function summary
 * @memberof MathWorkers.Stats
 */
MathWorkers.Stats.summary = function (data) {
    MathWorkers.util.checkNullOrUndefined(data);
    // Copy the data to a local array so that we can sort without affecting data
    var i;
    var arr = [];
    if (data instanceof MathWorkers.Vector) {
        for (i = 0; i &lt; data.array.length; ++i) {
            arr.push(data.array[i]);
        }
    } else if (data instanceof MathWorkers.Matrix) {
        for (i = 0; i &lt; data.nrows; ++i) {
            for (var j = 0; j &lt; data.ncols; ++j) {
                arr.push(data.array[i][j]);
            }
        }
    } else if (data instanceof Array || data instanceof Float64Array) {
        for (i = 0; i &lt; data.length; ++i) {
            arr.push(data[i]);
        }
    } else {
        throw new TypeError("Invalid data type for summary(). Must be Array, Float64Array, or Vector.");
    }

    var tmp;
    var n = arr.length;
    var tot = 0.0;
    var amax = Math.max.apply(Math, arr);
    var amin = Math.min.apply(Math, arr);
    for (i = 0; i &lt; n; ++i) {
        tot += arr[i];
    }
    var mean = tot / n;
    var variance = 0.0;
    for (i = 0; i &lt; n; ++i) {
        tmp = mean - arr[i];
        variance += tmp * tmp;
    }
    variance /= n;
    var stddev = Math.sqrt(variance);

    var q25, q50, q75;
    if (n >= 3) {
        // Sort for quartiles
        arr.sort(function (a, b) {
            return a - b
        });

        var x, y;
        x = getMedian(0, n - 1);
        q50 = x.median;
        y = getMedian(x.half, n - 1);
        q75 = y.median;
        if (x.odd) {
            y = getMedian(0, x.half);
            q25 = y.median;
        } else {
            y = getMedian(0, x.half - 1);
            q25 = y.median;
        }
    }

    function getMedian(nfrom, nto) {
        var m = nto - nfrom + 1;
        var half = (m / 2) | 0;
        var odd = (m % 2);
        var median = odd ? arr[nfrom + half] : 0.5 * (arr[nfrom + half - 1] + arr[nfrom + half]);
        return {median: median, half: half, odd: odd};
    }

    return {
        n: arr.length,
        mean: mean,
        variance: variance,
        stddev: stddev,
        minimum: amin,
        maximum: amax,
        quartile25: q25,
        quartile50: q50,
        quartile75: q75
    };
};


return MathWorkers;
}());</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Modules</h3><ul><li><a href="module-MathWorkers.html">MathWorkers</a></li></ul><h3>Classes</h3><ul><li><a href="MathWorkers.Coordinator.html">Coordinator</a></li><li><a href="MathWorkers.MathWorker.html">MathWorker</a></li><li><a href="MathWorkers.Matrix.html">Matrix</a></li><li><a href="MathWorkers.Vector.html">Vector</a></li></ul><h3>Namespaces</h3><ul><li><a href="MathWorkers.Batch.html">Batch</a></li><li><a href="MathWorkers.Global.html">Global</a></li><li><a href="MathWorkers.Stats.html">Stats</a></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-alpha9</a> on Mon Nov 10 2014 22:11:39 GMT-0600 (CST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
